# 一、基础算法

## 排序

**快速排序**

1.确定分界点 a[l]、a[h]、a[(l+h)/2]

分界点取到左边界时不能以左指针作为边界分界，分界点取到右边界时不能以右指针作为分解点，否则会死循环。注意c++中整数除法下取整。若采用左右端点作为分界点时数据特殊时可能会超时，则采用 （l + h） >> 1作为分界点，以右指针作为分界边界。

2.调整区间

以左右两个指针从两侧向中间扫描，当两个指针均不符合条件时，交换两指针所指向的数

3.递归处理左右两区间



```c++
void quick_sort(int q[], int l, int h)
{
    if(l >= h) return;

    int x = q[l + h >> 1], int i = l - 1, int j = h + 1;
    while(i<j){
        do i ++; while(q[i] < x);
        do j --; while(q[j] > x);
        if(i < j ) swap(q[i], q[j]);
    }

    quick_sort(q, l, j);
    quick_sort(q, j+1, h);

}
```

**归并排序**

```c++
/*
AcWing788. 逆序对的数量
给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。

逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<j 且 a[i]>a[j]，则其为一个逆序对；否则不是。
*/

#include <bits/stdc++.h>

using namespace std;
using i64 = long long;

int main()
{
    int n;
    cin >> n;
    int a[n + 5];
    for(int i = 0; i < n; i ++) cin >> a[i];
     
    i64 res = 0;
    function<void(int, int)> merge_sort = [&](int l, int r){
        if(l >= r) return;
        
        int mid  = l + r >> 1;
        
        merge_sort(l, mid);
        merge_sort(mid + 1, r);
        
        int temp[r - l + 1];
        int k = 0, i = l, j = mid + 1;
        while(i <= mid && j <= r){
            if(a[i] <= a[j]) temp[k ++] = a[i ++];
            else {
                res += (mid - i + 1);
                temp[k ++] = a[j ++];
            }
        }
        while(i <= mid) {
            temp[k ++] = a[i ++];
        }
        while(j <= r) temp[k ++] = a[j ++];
        
        
        for(int i = 0, j = l; j <= r;) a[j ++] = temp[i ++];
    };
    
    merge_sort(0, n - 1); 
    
    cout << res << endl;
    
    return 0;
}
```

## 二分

- 整数二分

  - 思想：满足条件的划分在一个区间，不满足条件的在另一个区间

  - 只要每次可以确定答案在某一半边就可以二分，不一定需要单调

  - 当更新区间为 l  = mid 时 mid要取 l + r  + 1 >> 1,原因是c++中整数除法为下取整，当把 l 更新为mid是若 l = r - 1，此时 mid = l + r >> 1 为l，陷入死循环。

```c++
/*
AcWing 789. 数的范围
给定一个按照升序排列的长度为 n（均在 1∼10000 范围内） 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 -1 -1。
*/
#include <iostream>

using namespace std;

const int N = 100010;
int a[N];
int n, q;

int main()
{
    cin >> n >> q;
    for(int i = 0; i < n; i ++) cin >> a[i];
    
    while(q --){
        int k;
        cin >> k;
        
        int l = 0, r = n - 1;
        while(l < r){
            int mid = l + r >> 1;
            if(a[mid] >= k) r = mid;
            else l = mid + 1;
        }
        
        if(a[l] != k){
            puts("-1 -1");
            continue;
        }else cout << l << ' ';
        
        l = 0, r = n - 1;
        while(l < r){
            int mid = l + r + 1 >> 1;
            if(a[mid] <= k) l = mid;
            else r = mid - 1;
        }
        cout << l << endl;
    }
    
    return 0;
}
```

- 浮点数二分

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

- 三分

  - 用途：确定单峰函数的极值
  - 做法：每个选择区间的两个三等分点，把不可能是答案的那三分之一区间去掉


```c++
/*
Codeforces Round #823 (Div. 2)-B
*/
#include <bits/stdc++.h>

using namespace std;
constexpr double eps = 1e-6;
constexpr int N = 100007;
double a[N], t[N];
int n;

double check(double x)
{
    double res = 0;
    for(int i = 1; i <= n; i ++)
        res = max(res, abs(a[i] - x) + t[i]);
    return res;
}

void sovle()
{   
    cin >> n;
    for(int i = 1; i <= n; i ++)
        cin >> a[i];
    for(int i = 1; i <= n; i ++) 
        cin >> t[i];

    double l = 0, r = 1e8;
    while(r - l > eps){
        double mid1 = l + (r - l) / 3.0;
        double mid2 = r - (r - l) / 3.0;
        if(check(mid1) >= check(mid2)) l = mid1;
        else r = mid2;
    }

    cout << l << "\n";
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setiosflags(ios::fixed) << setprecision(8);

    int T = 1;
    cin >> T;
    while(T --){
        sovle();
    }

    return 0;
}
```



## 高精度



**高精度加法**

用数组存储每一位数字，低位在前，高位在后，模拟加法执行的过程算出结果

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

**高精度减法**

与加法存储相同

```c++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )//t开始充当是否借位
    {
        t = A[i] - t;//t作为A[i] - B[i] - t 的结果
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);//这里当t > 0时，说明不用借位，运算结果为t
        if (t < 0) t = 1;		   //当 t < 0时，要借位，此时结果加10
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

**高精度乘法**

```c++
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )//以t作为存在条件 是为了加上最后一位
    {
        if (i < A.size()) t += A[i] * b;//因为以t作为存在条件了，所以这里需要判断i合法
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```

**高精度除法**

除法要从高位开始计算，因此为了保证与加减乘的统一，结果需要reverse

```c++
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;//不能在for内初始化会被覆盖掉，这里的r就不起作用了
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

## 前缀和与差分

**前缀和**

注意数组a从1开始 为了保证是s[r]  - s[l - 1]的边界适用

S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]

**子矩阵和**

S[i, j] = 第i行j列格子左上部分所有元素的和
计算s[i, j]:s[i, j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]

**差分**

*给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c

a是b的前缀和数组，b是的差分数组，不必去构造差分数组，运用*的思想，即可在读入a数组是构造完成b数组

**差分矩阵**

给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c

思想同差分

## 双指针

先写暴力算法，观察i ，j有什么单调关系，从而把枚举状态从O(n^2)优化到O(n)

```c++
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

## lowbit

返回x的二进制表示以及最低位1以及后面的0

```c++
int lowbit()
{
    return x & -x;
    // -x = ~x + 1
}
```

## 离散化

```c++
//以区间和为例子
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```



## 区间合并

区间已经按左端点排序，考察当前区间及下一个区间，初始条件设为无穷，不要忘记对最后一个区间的考察

```c
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

## RMQ

作用：快速找到一个区间内的最大或最小值

```c++
//预处理出f[i][j] 从i开始长度为2^j的区间内的最大值
f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1])
//预处理循环时从长度循环，不能从每个点循环
用两个预处理出来的区间可以覆盖任意一个合理区间
    query(l, r);
	int len = r - l + 1;
	int k = log(len) / log(2);//也可以预处理power[1 << i] = i, k = power[len];
	res = max(f[l][k], f[r - (1 << k) + 1][k]);
```





# 二、数据结构

## 单链表

用两个数组模拟链表，一个记录值，另一个记录next指针

```c++
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点，也就是节点编号
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```

## 双链表

用两个数组记录左右指针 0位置为头，1位置为尾

```c++
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

## 栈和队列

```c++
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
//普通队列
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}
```

***



## 单调队列和单调栈

保持队列或栈中元素单调

```c++
单调栈：常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
单调队列 ：常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

***



## kmp



- 性质 $n - ne[n]$ 就是把$1$到$n$覆盖的最小循环节长度， 如果$n$整除$n - ne[n]$, 那么其就是最小完全循环节长度

```c++
// s是长文本，p是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ ){
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```



## Trie树

用途：快速的存储和查找字符串

节点数为通常为每个串的最大长度乘以串的个数

```c++
son[N][M] N为节点个数，M为每个节点最多有多少个后代
 idx当前操作的是总共的第几个节点，s[n][m]中记录的是第n个节点的m（通常是把可能的字符情况映射到数字）字符是否存在，若存在为第几个节点
 若是记录串出现次数，cnt[N]数组记录每个节点结尾的串的个数
    
    int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;//（当前字符位置）
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';//(找出当前字符)
        if (!son[p][u]) son[p][u] = ++ idx;//（判断树中是否存在，不存在则新建）
        p = son[p][u];//（p移动到下一个字符位置）
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

```

## 可持久化trie树

可持久化的含义的就是记录trie树更新的每个版本，

核心思想就是记录每个版本与上个版本不一样的即可

```c++
代码思路大致如下
p为上一版本的根节点， q为新版本的根节点
p = root[i - 1], q = ++ idx;
if(p) tr[q] = tr[p];//所当前节点信息上一版本中有，复制过来即可
 tr[p][si] = ++ idx;//si为要插入的节点，新插入的节点总结总要从新建立，哪怕老版本中有，因为在新版本中要用到因此要从新建立，
 p = tr[p][si];		//在新版本中用不到的老版本信息，使用老版本即可
 q = tr[q][si];   	//这两行的意义为，先把老版本的信息完全复制过来，如果新版本中要用到老版本的，再从新建立
					//老版本没有的也从新建立

 
```

***



## 并查集

- 将两个集合合并

- 询问两个元素是否在同一个集合中

- 基本原理：每个集合用一颗树表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，$p[x]$表示$x$的父节点

```c++
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点 同时路径压缩
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n 
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);


(2)维护size的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点 同时路径压缩
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);


(3)维护到祖宗节点距离的并查集：

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量

```

两种并查集：

- 带边权的并查集

所有可以相互推出关系的元素在一个集合内，通常关系是一个循环，以到根节点的距离表示与根节点的关系，再由与根节点的关系推出各个点之间的关系，通常要维护一个表示距离的数组d[], d[i]表示i到其父节点的距离，路径压缩过程中可同时更新d[]，

- 带扩展域的并查集

每个集合内存的是元素关系，一个关系成立，则集合内的其他关系必然成立，每次合并的复杂度是O(k)的，对于关系较多的问题可能运行较为缓慢，各种关系的表示要确定好表示方式，避免一种表示，表示两种关系



****



## 树状数组

- 作用：求前缀和，修改某一个数后的前缀和

​		单点加法， 和区间和

​		因此要求的值必须能通过前缀和求出

- 时间复杂度：求前缀和$O(logn)$, 修改某一个数$O(logn)$

 

```c++
int lowbit(int x)
{
    return x & -x;
}
//修改
void add(int x, int c)
{
    for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}
//求值
int sum(int x)
{
    int res = 0;
    for(int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}
```



***



## 线段树

- 把区间分成线段，叶子节点只有单个元素，通常每个节点为一个s结构体，结构体中维护各种所需要的信息，用数组模拟线段树，空间要开$4 * N$

​		空间需要开$4$倍因为 节点编号可能达到$4n$这个量级，比$4n$要小，中间很多点没用到，实际上只用到$2*n - 1$个点

​		查询和修改复杂度均是$O(logn)$



```c++
/*
区间加询问区间和
*/
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

const int N = 100010;
struct node{
    int l, r;
    LL sum;
    int add;
}tr[N << 2];
int a[N];
int n, m;

void pushup(int u)
{
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void pushdown(node &rt, node &l, node &r)
{
    l.sum += 1ll * (l.r - l.l + 1) * rt.add;
    l.add += rt.add;
    r.sum += 1ll * (r.r - r.l + 1) * rt.add;
    r.add += rt.add;
    rt.add = 0; 
}

void pushdown(int u)
{
    pushdown(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if(l == r){
        tr[u] = {l, r, a[l], 0};
        return;
    }
    
    tr[u] = {l, r};
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}

void modify(int u, int l, int r, int d)
{
    if(l <= tr[u].l && tr[u].r <= r){
        tr[u].add += d;
        tr[u].sum += 1ll * (tr[u].r - tr[u].l + 1) * d;
        return;
    }

    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if(l <= mid) modify(u << 1, l, r, d);
    if(r > mid) modify(u << 1 | 1, l, r, d);
    pushup(u);
}

LL query(int u, int l, int r)
{
    if(l <= tr[u].l && tr[u].r <= r)
        return tr[u].sum;

    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    LL res = 0;
    if(l <= mid) res += query(u << 1, l, r);
    if(r > mid) res += query(u << 1 | 1, l, r);
    return res;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        cin >> a[i];

    build(1, 1, n);

    char op[2];
    int l, r, d;
    while(m --){
        cin >> op;
        if(op[0] == 'Q'){
            cin >> l >> r;
            cout << query(1, l, r) << "\n";
        }else{
            cin >> l >> r >> d;
            modify(1, l, r, d);
        }
    }

    return 0;
}
```



- 势能线段树

  这种线段树要维护的信息，难以对整个区间计算，比如对一个区间内的数开根号，取模等
  但其有一种奇妙的性质，就是修改超过一定次数后，再修改区间内的数不变
  势能线段树就是利用这种性质：对区间修改直接暴力递归到叶子节点修改，但在递归的过程中，若发现这个区间内的数修改后不变的话，就不用递归下去
  时间复杂度 假设每个叶子节点最多修改k次后不变， 则修改的复杂度就是$O(nlogn*k)$ 最坏情况下每个点修改k次
  查询复杂度就是正常的线段树复杂度$(nlogn)$
  
  

- 线段树合并
  - 动态开点，只把使用的点开出来
  - 线段树合并的复杂度大致是$O(logn)$的，空间开$4 * n * logn$

```c++
/*
有 n 个点，形成一个树状结构。

有 m 次发放操作，每次选择两个点 x,y，对 x 到 y 的路径上（包括 x,y）的每个点发放一袋 z 类型的物品。

求完成所有发放操作后，每个点存放最多的是哪种类型的物品。
n,z<=1e5
*/

#include <bits/stdc++.h>

using namespace std;
using LL = long long;
constexpr int N = 100007;
constexpr int M = N << 1;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][19];//16
int q[N];
int n, m;
vector<array<int, 3>> a(N);
vector<int> hs;
int root[N];//每个节点的对应线段树的根节点
int cnt;//已使用的节点
int ans[N];

struct node{
    int lc, rc, mx, id;
}tr[N * 80];

void add(int u, int v)
{
    e[idx] = v, ne[idx] = h[u], h[u] = idx ++;
    e[idx] = u, ne[idx] = h[v], h[v] = idx ++;
}

int find(int x)
{
    return lower_bound(hs.begin(), hs.end(), x) - hs.begin() + 1;
}

void bfs()
{
    memset(depth, 0x3f, sizeof(depth));
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    q[0] = 1;

    while(hh <= tt){
        auto t = q[hh ++];
        for(int i = h[t]; ~i; i = ne[i]){
            int ver = e[i];
            if(depth[ver] > depth[t] + 1){
                depth[ver] = depth[t] + 1;
                fa[ver][0] = t;
                for(int k = 1; k <= 16; k ++){
                    fa[ver][k] = fa[fa[ver][k - 1]][k - 1];
                }
                q[++ tt] = ver;
            }
        }
    }
}

int lca(int u, int v)
{
    if(depth[u] < depth[v]) swap(u, v);
    for(int k = 16; k >= 0; k --)
        if(depth[fa[u][k]] >= depth[v])
            u = fa[u][k];
    if(u == v) return u;
    for(int k = 16; k >= 0; k --)
        if(fa[u][k] != fa[v][k]){
            u = fa[u][k];
            v = fa[v][k];
        }
    return fa[u][0];
}

//线段树
void pushup(int u)
{
    if(tr[tr[u].lc].mx >= tr[tr[u].rc].mx){
        tr[u].mx = tr[tr[u].lc].mx;
        tr[u].id = tr[tr[u].lc].id;
    }else{
        tr[u].mx = tr[tr[u].rc].mx;
        tr[u].id = tr[tr[u].rc].id;
    }
}

void modify(int &u, int l, int r, int x, int k)
{
    if(u == 0) u = ++ cnt;
    if(l == r){
        tr[u].mx += k, tr[u].id = l;
        return;
    }
    int mid = l + r >> 1;
    if(x <= mid) modify(tr[u].lc, l, mid, x, k);
    else modify(tr[u].rc, mid + 1, r, x, k);
    pushup(u);
}

//合并线段树
int merge(int r1, int r2, int l, int r)
{
    if(!r1) return r2;
    if(!r2) return r1;

    if(l == r){
        tr[r1].mx += tr[r2].mx;
        return r1;
    }

    int mid = l + r >> 1;
    tr[r1].lc = merge(tr[r1].lc, tr[r2].lc, l, mid);
    tr[r1].rc = merge(tr[r1].rc, tr[r2].rc, mid + 1, r);
    pushup(r1);
    return r1;
}

void dfs(int u)
{
    for(int i = h[u]; ~i; i = ne[i]){
        int ver = e[i];
        if(ver == fa[u][0]) continue;
        dfs(ver);
        root[u] = merge(root[u], root[ver], 1, hs.size());
    }
    //要在这里求答案,因为合并父节点时可能会改变子节点的root信息
    if(tr[root[u]].mx != 0) ans[u] = hs[tr[root[u]].id - 1];
}

void sovle()
{   
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    for(int i = 1; i < n; i ++){
        int u, v;
        cin >> u >> v;
        add(u, v);
    }

    bfs();

    for(int i = 1; i <= m; i ++){
        cin >> a[i][0] >> a[i][1] >> a[i][2];
        hs.push_back(a[i][2]);
    }
    sort(hs.begin(), hs.end());
    hs.erase(unique(hs.begin(), hs.end()), hs.end());

    for(int i = 1; i <= m; i ++){
        auto [x, y, z] = a[i];
        int p = lca(x, y);
        z = find(z);
        modify(root[x], 1, hs.size(), z, 1);
        modify(root[y], 1, hs.size(), z, 1);
        modify(root[p], 1, hs.size(), z, -1);
        modify(root[fa[p][0]], 1, hs.size(), z, -1);
    }

    dfs(1);
    
    for(int i = 1; i <= n; i ++)
        cout << ans[i] << "\n";
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setiosflags(ios::fixed) << setprecision(2);
    int T = 1;
    //cin >> T;
    while(T --){
        sovle();
    }

    return 0;
}
```



## 可持久化线段树（主席树）

区间修改操作较为困难，

记录了线段树每次修改的情况，一共有m + 1个版本，m为操作次数，空树也为一个版本

空间要开N * 4 + M * logN, 空间要特别注意，很容易开小

每次修改就是把信息改变的节点从新生成即可，每次修改的节点大概是logN级别

主席树的存储方式不再沿用堆的存储方式，因为每个版本要开新的节点，用数组存储，每个元素是个节点，每个节点存在左右儿子，

节点中不在存储，左右边界，因此，插入、询问时要传入左右边界 ，经典的例子有acwing 257题 第k小数

可持久化线段树与可持久化trie不同，每一个版本节点数量相同，只是信息改变，因此，先复制上一版本的所有信息，信息改变的节点从新创建





## 平衡树（treap）

平衡树可快速插入和查找$O(logn)$

维护搜索树的性质的同时维护堆的性质，这两个性质的就可以使得树的形状确定，同时堆的性质使得树的高度不至于退化成一条链，平均树高$logn$

```c++
int root, idx;
struct Node{
    int lc, rc;
    int key, val;
    int cnt, size;
}tr[N];

void pushup(int p)
{
    tr[p].size = tr[tr[p].lc].size + tr[tr[p].rc].size + tr[p].cnt;
}

int get_node(int key)
{
    tr[++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void zag(int &p);
void build()
{
    get_node(-INF);
    get_node(INF);
    root = 1, tr[1].rc = 2;
    pushup(root);
    
    if(tr[1].val < tr[2].val) zag(root);
}

void zig(int &p)//右旋
{
    int q = tr[p].lc;
    tr[p].lc = tr[q].rc;
    tr[q].rc = p;
    p = q;
    pushup(tr[p].rc); pushup(p);
}

void zag(int &p)//左旋
{
    int q = tr[p].rc;
    tr[p].rc = tr[q].lc;
    tr[q].lc = p;
    p = q;
    pushup(tr[p].lc); pushup(p);
}

void insert(int &p, int key)//插入
{
    if(!p) p = get_node(key);
    else if(tr[p].key == key) tr[p].cnt ++;
    else if(key < tr[p].key){
        insert(tr[p].lc, key);
        if(tr[tr[p].lc].val > tr[p].val) zig(p);
    }else{
        insert(tr[p].rc, key);
        if(tr[tr[p].rc].val > tr[p].val) zag(p);
    }
    pushup(p);
}

void remove(int &p, int key)//删除
{
    if(!p) return;
    if(tr[p].key == key){
        if(tr[p].cnt > 1) tr[p].cnt --;
        else{
            if(tr[p].lc || tr[p].rc){
                if(!tr[p].rc || tr[tr[p].lc].val > tr[tr[p].rc].val){
                    zig(p);
                    remove(tr[p].rc, key);
                }else{
                    zag(p);
                    remove(tr[p].lc, key);
                }
            }else p = 0;
        }
    }else if(key < tr[p].key) remove(tr[p].lc, key);
    else remove(tr[p].rc, key);
    
    pushup(p);
}

int get_rank_by_key(int p, int key)//通过数值找排名
{
    if(!p) return 0;
    if(tr[p].key == key) return tr[tr[p].lc].size + 1;
    if(key < tr[p].key) return get_rank_by_key(tr[p].lc, key);
    else return tr[tr[p].lc].size + tr[p].cnt + get_rank_by_key(tr[p].rc, key);
}

int get_key_by_rank(int p, int rank)//通过排名找数值
{
    if(!p) return INF;
    if(rank <= tr[tr[p].lc].size) return get_key_by_rank(tr[p].lc, rank);
    if(rank <= tr[tr[p].lc].size + tr[p].cnt) return tr[p].key;
    else return get_key_by_rank(tr[p].rc, rank - tr[tr[p].lc].size - tr[p].cnt);
}

//这两段找前驱后继，很精简巧妙
int get_prec(int p, int key)//找前驱（严格小于）
{
    if(!p) return -INF;
    if(key <= tr[p].key) return get_prec(tr[p].lc, key);//若找小于等于 去掉等号
    else return max(tr[p].key, get_prec(tr[p].rc, key));
}

int get_succ(int p, int key)//找后继（严格大于）
{
    if(!p) return INF;
    if(key >= tr[p].key) return get_succ(tr[p].rc, key);//若找大于等于 去掉等号
    else return min(tr[p].key, get_succ(tr[p].lc, key));
}
```





## Splay

- $splay$ 能够$O(logn)$的原因是，在旋转时，对一条链的路径进行了折叠

- 核心只有$splay$和$rotate$两个函数，其他函数，依据需要添加即可。

​	$splay$函数的作用是把$x$节点调整到$k$节点的面，$k$为0，即让$x$作为根节点。

​	切记 如果将x调整到k的下面，一定先将k调整到根节点，不然会死循环。

​	处处$splay$!!!

```c++
/*AcWing 253.普通平衡树
您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：
	1.插入数值 x。
	2.删除数值 x(若有多个相同的数，应只删除一个)。
	3.查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
	4.查询排名为 x 的数值。
	5.求数值 x 的前驱(前驱定义为小于 x 的最大的数)。
	6.求数值 x 的后继(后继定义为大于 x 的最小的数)。
*/

#include <bits/stdc++.h>

#define endl '\n'

using namespace std;

const int N = 1000010, INF = 0x3f3f3f3f;
struct node{
	int s[2], v, p;
	int sz, cnt;

	void init(int _v, int _p){
		v = _v, p = _p;
		sz = cnt = 1;
	}
}tr[N];
int n;
int root, idx;
int tag;

void pushup(int u)
{
	tr[u].sz = tr[tr[u].s[0]].sz + tr[tr[u].s[1]].sz + tr[u].cnt;
}

void rotate(int x)
{
	int y = tr[x].p, z = tr[y].p;
	int k = x == tr[y].s[1];
	tr[x].p = z, tr[z].s[y == tr[z].s[1]] = x;
	tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
	tr[y].p = x, tr[x].s[k ^ 1] = y;
	pushup(y), pushup(x);
}

void splay(int x, int k)
{
	while(tr[x].p != k){
		int y = tr[x].p, z = tr[y].p;
		if(z != k)
			if((x == tr[y].s[1]) ^ (y == tr[z].s[1])) rotate(x);
			else rotate(y);
		rotate(x);
	}
	if(!k) root = x;
}

void insert(int v)
{	
	int u = root, p = 0;
	while(u){
		if(v == tr[u].v){
			tr[u].cnt ++;
			tr[u].sz ++;
			splay(u, 0);
			break;
		}
		p = u, u = tr[u].s[v > tr[u].v];
	}

	if(!u){
		u = ++ idx;
		if(p) tr[p].s[v > tr[p].v] = u;
		tr[u].init(v, p);
		splay(u, 0);
	}
}

int get_pre(int v)//找前驱
{
	int u = root, res = 0;
	while(u){
		if(tr[u].v >= v) u = tr[u].s[0];
		else res = u, u = tr[u].s[1];
	}

	return res;
}

int get_suc(int v)//找后继
{
	int u = root, res = 0;
	while(u){
		if(tr[u].v <= v) u = tr[u].s[1];
		else res = u, u = tr[u].s[0];
	}

	return res;
}

int get_rank(int u, int v)//通过数值找排名
{
	if(!u) return -1;
	if(tr[u].v == v){
		tag = u;
		return tr[tr[u].s[0]].sz + 1;
	}
	if(v < tr[u].v) return get_rank(tr[u].s[0], v);
	else return tr[tr[u].s[0]].sz + tr[u].cnt + get_rank(tr[u].s[1], v);
}

int get_k(int k)//通过排名找数值
{
	int u = root;
	while(u){
		if(tr[tr[u].s[0]].sz >= k) u = tr[u].s[0];
		else if(tr[tr[u].s[0]].sz < k && tr[tr[u].s[0]].sz + tr[u].cnt >= k) return u;
		else k -= tr[tr[u].s[0]].sz + tr[u].cnt, u = tr[u].s[1];
	}

	return -1;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n;
	insert(-INF);
	insert(INF);
	while(n --){
		int op, x;
		cin >> op >> x;
		if(op == 1){
			insert(x);
		}else if(op == 2){
			int l = get_pre(x), r = get_suc(x);
			splay(l, 0), splay(r, l);

			tr[tr[r].s[0]].sz --;
			if(-- tr[tr[r].s[0]].cnt == 0)
			 	tr[r].s[0] = 0;

			pushup(r), pushup(l);
			if(tr[r].s[0]) splay(tr[r].s[0], 0);
		}else if(op == 3){
			cout << get_rank(root, x) - 1 << endl;
			splay(tag, 0);
		}else if(op == 4){
			int u = get_k(x + 1);
			cout << tr[u].v << endl;
			splay(u, 0);
		}else if(op == 5){
			int u = get_pre(x);
			cout << tr[u].v << endl;
			splay(u, 0);
		}else{
			int u = get_suc(x);
			cout << tr[u].v << endl;
			splay(u, 0);
		}
	}

	return 0;
}
```





## 树套树

- 线段树套multiset

  ~~~c++
  /*
  AcWing 2488.树套树简单版
  请你写出一种数据结构，来维护一个长度为 n 的序列，其中需要提供以下操作：
  
  1 pos x，将 pos 位置的数修改为 x。
  2 l r x，查询整数 x 在区间 [l,r] 内的前驱(前驱定义为小于 x，且最大的数)。
  数列中的位置从左到右依次标号为 1∼n。
  
  区间 [l,r] 表示从位置 l 到位置 r 之间（包括两端点）的所有数字。
  
  区间内排名为 k 的值指区间内从小到大排在第 k 位的数值。（位次从 1 开始）
  */
  
  #include <bits/stdc++.h>
  
  #define endl '\n'
  
  using namespace std;
  
  const int N = 50010, INF = 0x3f3f3f3f;
  struct node{
      int l, r;
      multiset<int> ms;
  }tr[N << 2];
  int a[N];
  int n, m;
  
  void build(int u, int l, int r)
  {
      tr[u] = {l, r};
      tr[u].ms.insert(-INF), tr[u].ms.insert(INF);
      for(int i = l; i <= r; i ++)
          tr[u].ms.insert(a[i]);
      if(l == r) return;
      int mid = l + r >> 1;
      build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
  }
  
  void modify(int u, int pos, int x)
  {
      tr[u].ms.erase(tr[u].ms.find(a[pos]));
      tr[u].ms.insert(x);
      
      if(tr[u].l == tr[u].r) return;
  
      int mid = tr[u].l + tr[u].r >> 1;
      if(pos <= mid) modify(u << 1, pos, x);
      else modify(u << 1 | 1, pos, x); 
  }
  
  int query(int u, int l, int r, int x)
  {
      if(l <= tr[u].l && tr[u].r <= r){
          auto it = tr[u].ms.lower_bound(x);
          it --;
          return *it;
      }
  
      int mid = tr[u].l + tr[u].r >> 1;
      int res = -INF;
      if(l <= mid) res = max(res, query(u << 1, l, r, x));
      if(r > mid) res = max(res, query(u << 1 | 1, l, r, x));
      return res;
  }
  
  int main()
  {   
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
  
      cin >> n >> m;
      for(int i = 1; i <= n; i ++)
          cin >> a[i];
  
      build(1, 1, n);
  
      while(m --){
          int op, l, r, x;
          cin >> op;
          if(op == 1){
              cin >> l >> x;
              modify(1, l, x);
              a[l] = x;
          }else{
              cin >> l >> r >> x;
              cout << query(1, l, r, x) << endl;
          }
      }
  
      return 0;
  }
  
  ~~~

  

- 线段树套splay

  ```c++
  /*
  AcWing 2476.树套树
  请你写出一种数据结构，来维护一个长度为 n 的数列，其中需要提供以下操作：
  
  1 l r x，查询整数 x 在区间 [l,r] 内的排名。
  2 l r k，查询区间 [l,r] 内排名为 k 的值。
  3 pos x，将 pos 位置的数修改为 x。
  4 l r x，查询整数 x 在区间 [l,r] 内的前驱(前驱定义为小于 x，且最大的数)。
  5 l r x，查询整数 x 在区间 [l,r] 内的后继(后继定义为大于 x，且最小的数)。
  数列中的位置从左到右依次标号为 1∼n。
  
  区间 [l,r] 表示从位置 l 到位置 r 之间（包括两端点）的所有数字。
  
  区间内排名为 k 的值指区间内从小到大排在第 k 位的数值。（位次从 1 开始）
  */
  
  #include <bits/stdc++.h>
  
  #define endl '\n'
  
  using namespace std;
  
  const int N = 15000010, INF = 0x3f3f3f3f;
  struct node{
      int s[2], v, p;
      int sz;
  
      void init(int _v, int _p){
          v = _v, p = _p;
          sz = 1;
      }
  }tr[N];
  int L[N], R[N], T[N], idx;
  int n, m;
  int a[N];
  
  //splay
  void pushup(int u)
  {
      tr[u].sz = tr[tr[u].s[0]].sz + tr[tr[u].s[1]].sz + 1;
  }
  
  void rotate(int x)
  {
      int y = tr[x].p, z = tr[y].p;
      int k = x == tr[y].s[1];
      tr[x].p = z, tr[z].s[y == tr[z].s[1]] = x;
      tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
      tr[y].p = x, tr[x].s[k ^ 1] = y;
      pushup(y), pushup(x);
  }
  
  void splay(int &root, int x, int k)
  {
      while(tr[x].p != k){
          int y = tr[x].p, z = tr[y].p;
          if(z != k)
              if((x == tr[y].s[1]) ^ (y == tr[z].s[1])) rotate(x);
              else rotate(y);
          rotate(x);
      }
  
      if(!k) root = x;
  }
  
  void insert(int &root, int v)
  {
      int u = root, p = 0;
      while(u) p = u, u = tr[u].s[v > tr[u].v];
      u = ++ idx;
      if(p) tr[p].s[v > tr[p].v] = u;
      tr[u].init(v, p);
      splay(root, u, 0);
  }
  
  int get_pre(int root, int v)//找数值前驱
  {
      int u = root, res = 0;
      while(u){
          if(tr[u].v >= v) u = tr[u].s[0];
          else res = u, u = tr[u].s[1]; 
      }
  
      return res;
  }
  
  int get_suc(int root, int v)//找数值后继
  {
      int u = root, res = 0;
      while(u){
          if(tr[u].v <= v) u = tr[u].s[1];
          else res = u, u = tr[u].s[0];
      }
  
      return res;
  }
  
  int get_k(int root, int v)//小于v的数值个数
  {
      int u = root, res = 0;
      while(u){
          if(tr[u].v < v) res += tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];
          else u = tr[u].s[0];
      }
  
      return res;
  }
  
  //线段树
  void build(int u, int l, int r)
  {
      L[u] = l, R[u] = r;
      insert(T[u], -INF), insert(T[u], INF);
      for(int i = l; i <= r; i ++)
          insert(T[u], a[i]);
      if(l == r) return;
  
      int mid = l + r >> 1;
      build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
  }
  
  void update(int &root, int x, int y)//每个树中区间更新
  {   
      int u = root;
      while(u){
          if(tr[u].v == x) break;
          else if(tr[u].v < x) u = tr[u].s[1];
          else u = tr[u].s[0];
      }
      splay(root, u, 0);
      int l = tr[u].s[0];
      while(tr[l].s[1]) l = tr[l].s[1];
      int r = tr[u].s[1];
      while(tr[r].s[0]) r = tr[r].s[0];
      splay(root, l, 0), splay(root, r, l);
      tr[r].s[0] = 0;
      pushup(r), pushup(l);
      insert(root, y);
  }
  
  void modify(int u, int pos, int x)//线段树修改
  {
      update(T[u], a[pos], x);
      if(L[u] == R[u]) return;
      int mid = L[u] + R[u] >> 1;
      if(pos <= mid) modify(u << 1, pos, x);
      else modify(u << 1 | 1, pos, x);
  }
  
  int query_rk(int u, int l, int r, int x)//查询共有多少个小于给定数值的，排名要+1
  {
      if(l <= L[u] && R[u] <= r) return get_k(T[u], x) - 1;
      
      int mid = L[u] + R[u] >> 1;
      int res = 0;
      if(l <= mid) res += query_rk(u << 1, l, r, x);
      if(r > mid) res += query_rk(u << 1 | 1, l, r, x);
      return res;
  }
  
  int query_pre(int u, int l, int r, int x)//找数值前驱
  {
      if(l <= L[u] && R[u] <= r){
          int res = get_pre(T[u], x);
          return tr[res].v;
      }
  
      int mid = L[u] + R[u] >> 1;
      int res = -INF;
      if(l <= mid) res = max(res, query_pre(u << 1, l, r, x));
      if(r > mid) res = max(res, query_pre(u << 1 | 1, l, r, x));
      return res;
  }
  
  int query_suc(int u, int l, int r, int x)//找数值后继
  {
      if(l <= L[u] && R[u] <= r){
          int res = get_suc(T[u], x);
          return tr[res].v;
      }
  
      int mid = L[u] + R[u] >> 1;
      int res = INF;
      if(l <= mid) res = min(res, query_suc(u << 1, l, r, x));
      if(r > mid) res = min(res, query_suc(u << 1 | 1, l, r, x));
      return res;
  }
  
  int main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
  
      cin >> n >> m;
      for(int i = 1; i <= n; i ++)
          cin >> a[i];
  
      build(1, 1, n);
  
      while(m --){
          int op, pos, l, r, x;
          cin >> op;
          
          if(op == 1){
              cin >> l >> r >> x;
              cout << query_rk(1, l, r, x) + 1 << endl;
          }else if(op == 2){
              cin >> l >> r >> x;
              int ls = 0, rs = 1e8;
              while(ls < rs){
                  int mid = ls + rs + 1 >> 1;
                  if(query_rk(1, l, r, mid) + 1 <= x) ls = mid;
                  else rs = mid - 1;
              }
              cout << rs << endl;
          }else if(op == 3){
              cin >> pos >> x;
              modify(1, pos, x);
              a[pos] = x;
          }else if(op == 4){
              cin >> l >> r >> x;
              cout << query_pre(1, l, r, x) << endl;
          }else if(op == 5){
              cin >> l >> r >> x;
              cout << query_suc(1, l, r, x) << endl;
          }
      }
  
      return 0;
  }
  ```

  

- 线段树套线段树(外层权值线段树，内层动态开点)

  ```c++
  /*
  AcWing 2306.K大数查询
  有 N 个位置，M 个操作。每个位置可以同时存储多个数。
  
  操作有两种，每次操作:
  
  如果是 1 a b c 的形式，表示在第 a 个位置到第 b 个位置，每个位置加入一个数 c。
  如果是 2 a b c 的形式，表示询问从第 a 个位置到第 b 个位置，第 c 大的数是多少。
  */
  
  #include <bits/stdc++.h>
  
  #define endl '\n'
  
  using namespace std;
  
  const int N = 50010, M = N * 400;
  struct node{
      int lc, rc;
      int sum, add;
  }tr[M];
  int L[N << 2], R[N << 2], T[N << 2], idx;
  int n, m;
  struct query{
      int op, a, b, c;
  }q[N];
  vector<int> hs;
  
  int get(int x)
  {
      return lower_bound(hs.begin(), hs.end(), x) - hs.begin();
  }
  
  int mixed(int l1, int r1, int l2, int r2)
  {
      return min(r2, r1) - max(l2, l1) + 1;
  }
  
  //内层线段树，动态开点，只开用到的点, 标记可持久化
  void update(int u, int l, int r, int ml, int mr)//更新内层线段树
  {
      tr[u].sum += mixed(l, r, ml, mr);
      if(ml <= l && r <= mr){
          tr[u].add ++;
          return;
      }
  
      int mid = l + r >> 1;
      if(ml <= mid){ 
          if(!tr[u].lc) tr[u].lc = ++ idx;
          update(tr[u].lc, l, mid, ml, mr);
      }
      if(mr > mid){
          if(!tr[u].rc) tr[u].rc = ++ idx;
          update(tr[u].rc, mid + 1, r, ml, mr);
      }
  }
  
  int get_sum(int u, int l, int r, int ml, int mr, int add)
  {
      if(ml <= l && r <= mr) return tr[u].sum + (r - l + 1) * add;
  
      int mid = l + r >> 1;
      add += tr[u].add;
      int res = 0;
      if(ml <= mid){
          if(tr[u].lc) res += get_sum(tr[u].lc, l, mid, ml, mr, add);
          else res += mixed(l, mid, ml, mr) * add;
      }
  
      if(mr > mid){ 
          if(tr[u].rc) res += get_sum(tr[u].rc, mid + 1, r, ml, mr, add);
          else res += mixed(mid + 1, r, ml, mr) * add;
      }
  
      return res;
  }
  
  //外层线段树， 权值线段树
  void build(int u, int l, int r)
  {
      L[u] = l, R[u] = r, T[u] = ++ idx;
      if(l == r) return;
      int mid = l + r >> 1;
      build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
  }
  
  void modify(int u, int l, int r, int c)
  {
      update(T[u], 1, n, l, r);
      if(L[u] == R[u]) return;
      int mid = L[u] + R[u] >> 1;
      if(c <= mid) modify(u << 1, l, r, c);
      else modify(u << 1 | 1, l, r, c);
  }
  
  int query(int u, int l, int r, int c)
  {
      if(L[u] == R[u]) return R[u];
      int mid = L[u] + R[u] >> 1;
      int k = get_sum(T[u << 1 | 1], 1, n, l, r, 0);//右子树里有多少在l,r内的权值
      if(k >= c) return query(u << 1 | 1, l, r, c);
      else return query(u << 1, l, r, c - k);
  }
  
  int main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
  
      cin >> n >> m;
      for(int i = 0; i < m; i ++){
          int op, a, b, c;
          cin >> op >> a >> b >> c;
          q[i] = {op, a, b, c};
          if(op == 1) hs.push_back(c);
      }
  
      //数值离散化
      sort(hs.begin(), hs.end());
      hs.erase(unique(hs.begin(), hs.end()), hs.end());
      build(1, 0, (int)hs.size() - 1);
  
      for(int i = 0; i < m; i ++){
          int op = q[i].op, a = q[i].a, b = q[i].b, c = q[i].c;
          if(op == 1){
              modify(1, a, b, get(c));
          }else{
              cout << hs[query(1, a, b, c)] << endl;
          }
      }
  
      return 0;
  }
  ```




## 分块

思想把整个区间分成$sqrt(n)$个小区间，对于整个包含于查询或修改的小区间，标记或直接询问，对于部分包含于查询或修改区间的小区间直接暴力

整个包含的小区间不超过$sqrt(n)$个， 暴力修改或查询的点也是$sqrt(n)$ 级别，这样单次总复杂度就是$O(sqrt(n))$.

```c++
/*
AcWing 243.一个简单的整数问题2
给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：

C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。
Q l r，表示询问数列中第 l∼r 个数的和。
对于每个询问，输出一个整数表示答案。
*/

#include <bits/stdc++.h>

#define endl '\n'

using namespace std;
using LL = long long;

const int N = 100010, M = 350;
LL add[M], sum[M];
int a[N];
int n, m, len;

int get(int x)
{
    return (x - 1) / len;
}

void change(int l, int r, int d)
{
    if(get(l) == get(r)){
        for(int i = l; i <= r; i ++) a[i] += d, sum[get(i)] += d;
    }else{
        int i = l, j = r;
        while(get(i) == get(l)) a[i] += d, sum[get(i)] += d, i ++;
        while(get(j) == get(r)) a[j] += d, sum[get(j)] += d, j --;
        for(int k = get(i); k <= get(j); k ++) add[k] += d, sum[k] += 1ll * len * d;
    }
}

LL query(int l, int r)
{
    LL res = 0;
    if(get(l) == get(r)){
        for(int i = l; i <= r; i ++) res += a[i] + add[get(i)];
    }else{
        int i = l, j = r;
        while(get(i) == get(l)) res += a[i] + add[get(i)], i ++;
        while(get(j) == get(r)) res += a[j] + add[get(j)], j --;
        for(int k = get(i); k <= get(j); k ++) res += sum[k];
    }
    return res;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    len = sqrt(n);
    for(int i = 1; i <= n; i ++){
        cin >> a[i];
        sum[get(i)] += a[i];
    }

    char op[2];
    int l, r, d;
    while(m --){
        cin >> op;
        if(op[0] == 'Q'){
            cin >> l >> r;
            cout << query(l, r) << endl;
        }else{
            cin >> l >> r >> d;
            change(l, r, d);
        }
    }

    return 0;
}
```



## 莫队

- 基础莫队

  ```c++
  /*
  AcWing.2492.HH的项链
  HH 有一串由各种漂亮的贝壳组成的项链。
  
  HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。
  
  HH 不断地收集新的贝壳，因此他的项链变得越来越长。
  
  有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？
  
  这个问题很难回答，因为项链实在是太长了。
  
  于是，他只好求助睿智的你，来解决这个问题。
  */
  
  #include <bits/stdc++.h>
  
  #define endl '\n'
  
  using namespace std;
  
  const int N = 50010, M = 200010;
  int a[N];
  int cnt[1000010];
  struct query{
      int id, l, r;
  }qr[M];
  int ans[M];
  int n, m, len;
  
  int get(int x)
  {
      return x / len;
  }
  
  //在同一块内，右端点递增排序，不同块内，块递增排序
  bool cmp(const query &a, const query &b)
  {
      int i = get(a.l), j = get(b.l);
      if(i != j) return i < j;
      return a.r < b.r;
  }
  
  int add(int x, int &res)
  {
      if(++ cnt[x] == 1) res ++;
  }
  
  int sub(int x, int &res)
  {
      if(-- cnt[x] == 0) res --;
  }
  
  int main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
  
      cin >> n;
      len = sqrt(n);
      for(int i = 1; i <= n; i ++)
          cin >> a[i];
  
      cin >> m;
      for(int i = 1; i <= m; i ++){
          int l, r;
          cin >> l >> r;
          qr[i] = {i, l, r};
      }
  
      sort(qr + 1, qr + 1 + m, cmp);
      
      int i = 0, j = 1, res = 0;
      for(int k = 1; k <= m; k ++){
          int id = qr[k].id, l = qr[k].l, r = qr[k].r;
          //注意先加减还是后加减
          while(i < r) add(a[++ i], res);
          while(i > r) sub(a[i --], res);
          while(j > l) add(a[-- j], res);
          while(j < l) sub(a[j ++], res);
          ans[id] = res;
      }
  
      for(int i = 1; i <= m; i ++)
          cout << ans[i] << endl;
  
      return 0;
  }
  ```




- 带修莫队

  分块的大小为$\sqrt[3]{n*t}$,  可以达到最块理论复杂度$O(\sqrt[3]{n^4*t})$ , t 为修改次数

  ```c++
  /*
  AcWing 2521. 数颜色
  墨墨购买了一套 N 支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。
  
  墨墨会像你发布如下指令：
  
  Q L R 代表询问你从第 L 支画笔到第 R 支画笔中共有几种不同颜色的画笔。
  R P Col 把第 P 支画笔替换为颜色 Col。
  为了满足墨墨的要求，你知道你需要干什么了吗？
  */
  
  #include <bits/stdc++.h>
  
  #define endl '\n'
  
  using namespace std;
  
  const int N = 10010, M = 1000010;
  int cnt[M];
  int a[N], ans[N];
  struct query{
      int id, l, r, t;
  }qr[N];
  struct change{
      int p, x;
  }cg[N];
  int n, m, mq, mc, len;
  
  int get(int x)
  {
      return x / len;
  }
  
  //按照左端点所在块编号，右端点所在块编号，第几个修改版本三关键字排序
  bool cmp(const query &a, const query &b)
  {
      int al = get(a.l), ar = get(a.r);
      int bl = get(b.l), br = get(b.r);
      if(al != bl) return al < bl;
      if(ar != br) return ar < br;
      return a.t < b.t;
  }
  
  void add(int x, int &res)
  {
      if(++ cnt[x] == 1) res ++;
  }
  
  void sub(int x, int &res)
  {
      if(-- cnt[x] == 0) res --;
  }
  
  int main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
  
      cin >> n >> m;
      for(int i = 1; i <= n; i ++)
          cin >> a[i];
  
      for(int i = 1; i <= m; i ++){
          char op[2];
          int l, r;
          cin >> op >> l >> r;
          if(op[0] == 'Q'){
              mq ++, qr[mq] = {mq, l, r, mc};
          }else{
              cg[++ mc] = {l, r};
          }
      }
      len = cbrt(1.0 * n * max(1, mc)) + 1;
  
      sort(qr + 1, qr + 1 + mq, cmp);
  
      int i = 0, j = 1, t = 0, res = 0;
      for(int k = 1; k <= mq; k ++){
          int id = qr[k].id, l = qr[k].l, r = qr[k].r, tq = qr[k].t;
          while(i < r) add(a[++ i], res);
          while(i > r) sub(a[i --], res);
          while(j > l) add(a[-- j], res);
          while(j < l) sub(a[j ++], res);
          while(t < tq){
              t ++;
              int p = cg[t].p, &x = cg[t].x;
              if(j <= p && p <= i){
                  sub(a[p], res);
                  add(x, res);
              }
              swap(x, a[p]);
          }
          while(t > tq){
              int p = cg[t].p, &x = cg[t].x;
              if(j <= p && p <= i){
                  sub(a[p], res);
                  add(x, res);
              }
              swap(x, a[p]);
              t --;
          }
          ans[id] = res;
      }
  
      for(int i = 1; i <= mq; i ++)
          cout << ans[i] << endl;
  
      return 0;
  }
  ```
  
- 回滚莫队
  对于每个分块，在块内的查询暴力做，块间的按照右端点排序，依次查询，每次查询要把前一次查询在块内的部分回滚掉

  ```c++
  /*
  AcWing 2523.历史研究
  IOI 国历史研究的第一人——JOI 教授，最近获得了一份被认为是古代 IOI 国的住民写下的日记。
  
  JOI 教授为了通过这份日记来研究古代 IOI 国的生活，开始着手调查日记中记载的事件。
  
  日记中记录了连续 N 天发生的时间，大约每天发生一件。
  
  事件有种类之分。第 i 天 (1≤i≤N) 发生的事件的种类用一个整数 Xi 表示，Xi 越大，事件的规模就越大。
  
  JOI 教授决定用如下的方法分析这些日记：
  
  选择日记中连续的一些天作为分析的时间段
  事件种类 t 的重要度为 t× (这段时间内重要度为 t 的事件数)
  计算出所有事件种类的重要度，输出其中的最大值
  现在你被要求制作一个帮助教授分析的程序，每次给出分析的区间，你需要输出重要度的最大值。
  数据范围1e5
  */
  
  #include <bits/stdc++.h>
  
  #define endl '\n'
  
  using namespace std;
  using LL = long long;
  
  const int N = 100010;
  int a[N], cnt[N];
  LL ans[N];
  struct query{
      int id, l, r;
  }qr[N];
  int n, m, len;
  vector<int> hs;
  
  int get(int x)
  {
      return x / len;
  }
  
  bool cmp(const query &a, const query &b)
  {
      int i = get(a.l), j = get(b.l);
      if(i != j) return i < j;
      return a.r < b.r;
  }
  
  void add(int x, LL &res)
  {
      cnt[x] ++;
      res = max(res, 1ll * cnt[x] * hs[x]);
  }
  
  int main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
  
      cin >> n >> m;
      len = sqrt(n);
      for(int i = 1; i <= n; i ++){
          cin >> a[i];
          hs.push_back(a[i]);
      }
  
      sort(hs.begin(), hs.end());
      hs.erase(unique(hs.begin(), hs.end()), hs.end());
      for(int i = 1; i <= n; i ++)
          a[i] = lower_bound(hs.begin(), hs.end(), a[i]) - hs.begin();
  
      for(int i = 1; i <= m; i ++){
          int l, r;
          cin >> l >> r;
          qr[i] = {i, l, r};
      }
  
      sort(qr + 1, qr + 1 + m, cmp);
  
      for(int x = 1; x <= m;){
          int y = x;
          while(y <= m && get(qr[y].l) == get(qr[x].l)) y ++;
          int right = get(qr[x].l) * len + len - 1;
  
          //处理块内询问
          while(x < y && qr[x].r <= right){
              LL res = 0;
              int id = qr[x].id, l = qr[x].l, r = qr[x].r;
              for(int k = l; k <= r; k ++) add(a[k], res);
              ans[id] = res;
              for(int k = l; k <= r; k ++) cnt[a[k]] --;
              x ++;
          }
  
          //处理块间询问
          LL res = 0;
          int i = right, j = right + 1;
          while(x < y){
              int id = qr[x].id, l = qr[x].l, r = qr[x].r;
              while(i < r) add(a[++ i], res);
              LL backup = res;
              while(j > l) add(a[-- j], res);
              ans[id] = res;
              while(j < right + 1) cnt[a[j ++]] --;
              res = backup;
              x ++;
          }
          memset(cnt, 0, sizeof(cnt));
      }
  
      for(int i = 1; i <= m; i ++)
          cout << ans[i] << endl;
  
      return 0;
  }
  ```

  

- 树上莫队

  - 核心：把树上路径转化为序列，通常转化为欧拉序列
  - 欧拉序列：dfs遍历一个树，第一次遍历到一个点时，把其加入序列，回溯时再把其加入序列，得到就是欧拉序列
  - 性质：对于a, b两个点 $first[a] < first[b]$
    - 若$lca(a, b) = a$ 则对应的序列中的区间为$first[a] \approx fisrt[b]$
    - 若$lca(a, b) \neq a$ 则对应的序列中的区间为$last[a] \approx firat[b] + lca(a, b)$



```c++
/*
AcWing 2534.树上计数2
给定一棵 N 个节点的树，节点编号从 1 到 N，每个节点都有一个整数权值。

现在，我们要进行 M 次询问，格式为 u v，对于每个询问你需要回答从 u 到 v 的路径上（包括两端点）共有多少种不同的点权值。
1≤N≤40000,
1≤M≤105,
1≤x,y,u,v≤N,
各点权值均在 int 范围内。
*/

#include <bits/stdc++.h>

#define endl '\n'

using namespace std;

const int N = 100010;
int h[N], e[N], ne[N], idx;
int seq[N], top;
int first[N], last[N];
int depth[N], f[N][16];
struct query{
	int id, l, r, p;
}qr[N];
int a[N], ans[N], cnt[N];
bool st[N];
int n, m, len;
vector<int> hs;

void add(int a, int b, int edge)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
	e[idx] = a, ne[idx] = h[b], h[b] = idx ++;
}

void dfs(int u, int fa)
{
	seq[++ top] = u;
	first[u] = top;
	for(int i = h[u]; ~i; i = ne[i]){
		int ver = e[i];
		if(ver == fa) continue;
		dfs(ver, u);
	}
	seq[++ top] = u;
	last[u] = top;
}

void bfs()
{
	int q[N] = {0};
	int hh = 0, tt = 0;
	q[0] = {1};
	memset(depth, 0x3f, sizeof(depth));
	depth[0] = 0, depth[1] = 1;

	while(hh <= tt){
		int t = q[hh ++];

		for(int i = h[t]; ~i; i = ne[i]){
			int ver = e[i];
			if(depth[ver] > depth[t] + 1){
				depth[ver] = depth[t] + 1;
				f[ver][0] = t;
				for(int k = 1; k <= 15; k ++)
					f[ver][k] = f[f[ver][k - 1]][k - 1];
				q[++ tt] = ver;
			}
		}
	}
}

int lca(int a, int b)
{
	if(depth[a] < depth[b]) swap(a, b);
	for(int k = 15; k >= 0; k --)
		if(depth[f[a][k]] >= depth[b])
			a = f[a][k];
	if(a == b) return a;

	for(int k = 15; k >= 0; k --)
		if(f[a][k] != f[b][k]){
			a = f[a][k];
			b = f[b][k];
		}
	return f[a][0];
}

int get(int x)
{
	return x / len;
}

bool cmp(const query &a, const query &b)
{
	int i = get(a.l), j = get(b.l);
	if(i != j) return i < j;
	return a.r < b.r;
}

void add(int x, int &res)
{
	st[x] ^= 1;
	if(st[x]){
		if(++ cnt[a[x]] == 1) res ++;
	}else{
		if(-- cnt[a[x]] == 0) res --;
	}
}

int main()
{	
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n >> m;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
		hs.push_back(a[i]);
	}

	sort(hs.begin(), hs.end());
	hs.erase(unique(hs.begin(), hs.end()), hs.end());
	for(int i = 1; i <= n; i ++)
		a[i] = lower_bound(hs.begin(), hs.end(), a[i]) - hs.begin();

	memset(h, -1, sizeof(h));
	for(int i = 0; i < n - 1; i ++){
		int x, y;
		cin >> x >> y;
		add(x, y, 1);
	}

	//预处理欧拉序、 lca
	dfs(1, -1);
	bfs();

	len = sqrt(top);
	for(int i = 1; i <= m; i ++){
		int a, b;
		cin >> a >> b;
		if(first[a] > first[b]) swap(a, b);
		int p = lca(a, b);
		if(a == p) qr[i] = {i, first[a], first[b]};
		else qr[i] = {i, last[a], first[b], p};
	}

	sort(qr + 1, qr + 1 + m, cmp);

	//莫队
	int i = 0, j = 1, res = 0;
	for(int k = 1; k <= m; k ++){
		int id = qr[k].id, l = qr[k].l, r = qr[k].r, p = qr[k].p;
		while(i < r) add(seq[++ i], res);
		while(i > r) add(seq[i --], res);
		while(j > l) add(seq[-- j], res);
		while(j < l) add(seq[j ++], res);
		if(p) add(p, res);
		ans[id] = res;
		if(p) add(p, res); 
	}

	for(int i = 1; i <= m; i ++)
		cout << ans[i] << endl;

	return 0;
}
```



***



## 树链剖分

- 概念
  - 重儿子：一个节点的儿子所在子树中节点个数最多的儿子
  - 轻儿子：除了重儿子外的其他儿子
  - 重边：连接父节点和重儿子的边
  - 轻边：连接父节点和轻儿子的边
  - 重链：由所有重边组成的边，每个点一定在一个重链中，单个节点也可构成重链
- 如何解决树上问题
  - 将一颗树转化为序列，采用优先遍历重儿子的方式dfs, 保证重链在序列中连续
  - 树中路径转化为$logn$个的连续区间（重链），采用线段树等数据结构维护信息即可
- 性质
  - 定理：树中任意一条路径都可以转化为$logn$个连续区间（重链）
  - 证明：考虑极端情况，从根节点走到任意叶节点，走过的重链数量等于走过的轻边数量，每走过一个轻边，子树大小至少减小二分之一，因此从根节点走到叶子节点最多都$logn$条轻边，即最多走过$logn$个重链，即走过$logn$个连续区间
- tips
  - 点权转边权：把边权转到子节点上即可，除了根节点，其他节点上都是权值，此时修改和查询不能计算路径上最高的节点。
- 时间复杂度
  - 最坏的操作为用线段树每个维护$logn$个连续区间，因此时间复杂度为$O(n*(logn)^2)$

~~~c++
/*
AcWing2568.树链剖分
给定一棵树，树中包含 n 个节点（编号 1∼n），其中第 i 个节点的权值为 ai。

初始时，1 号节点为树的根节点。

现在要对该树进行 m 次操作，操作分为以下 4 种类型：

1 u v k，修改路径上节点权值，将节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值增加 k。
2 u k，修改子树上节点权值，将以节点 u 为根的子树上的所有节点的权值增加 k。
3 u v，询问路径，询问节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值和。
4 u，询问子树，询问以节点 u 为根的子树上的所有节点的权值和。
数据范围
1≤n,m≤10^5,
0≤ai,k≤10^5,
1≤u,v,x,y≤n
*/

#include <bits/stdc++.h>

#define endl '\n'

using namespace std;
using LL = long long;

const int N = 100010, M = N << 1;
int a[N], id[N], na[N];
int h[N], e[M], ne[M], idx;
int depth[N], top[N], sz[N], fa[N], son[N], cnt;
int n, m;
struct node{
    int l, r;
    LL add, sum;
}tr[N << 2];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, ne[idx] = h[b], h[b] = idx ++;
}

void pushup(int u)
{
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void pushdown(node &rt, node &l, node &r)
{
    if(rt.add){
        l.add += rt.add, l.sum += (l.r - l.l + 1) * rt.add;
        r.add += rt.add, r.sum += (r.r - r.l + 1) * rt.add;
        rt.add = 0;
    }
}

void pushdown(int u)
{
    pushdown(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if(l == r){
        tr[u] = {l, r, 0, na[l]};
        return;
    }

    tr[u] = {l, r};
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}

void modify(int u, int l, int r, int k)
{
    if(l <= tr[u].l && tr[u].r <= r){
        tr[u].add += k;
        tr[u].sum += (tr[u].r - tr[u].l + 1) * k;
        return;
    }

    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if(l <= mid) modify(u << 1, l, r, k);
    if(r > mid) modify(u << 1 | 1, l, r, k);
    pushup(u);
}

LL query(int u, int l, int r)
{
    if(l <= tr[u].l && tr[u].r <= r) return tr[u].sum;

    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    LL res = 0;
    if(l <= mid) res += query(u << 1, l, r);
    if(r > mid) res += query(u << 1 | 1, l, r);
    return res;
}

void dfs1(int u, int father, int dep)
{
    sz[u] = 1, depth[u] = dep, fa[u] = father ;
    for(int i = h[u]; ~i; i = ne[i]){
        int ver = e[i];
        if(ver == father) continue;
        dfs1(ver, u, dep + 1);
        sz[u] += sz[ver];
        if(sz[son[u]] < sz[ver]) son[u] = ver;
    }
}

void dfs2(int u, int t)
{
    id[u] = ++ cnt, na[cnt] = a[u], top[u] = t;
    if(!son[u]) return;
    dfs2(son[u], t);
    for(int i = h[u]; ~i; i = ne[i]){
        int ver = e[i];
        if(ver == son[u] || ver == fa[u]) continue;
        dfs2(ver, ver);
    }
}

void modify_path(int u, int v, int k)
{
    while(top[u] != top[v]){
        if(depth[top[u]] < depth[top[v]]) swap(u, v);
        modify(1, id[top[u]], id[u], k);
        u = fa[top[u]];
    }

    if(depth[u] < depth[v]) swap(u, v);
    modify(1, id[v], id[u], k);
}

LL query_path(int u, int v)
{
    LL res = 0;
    while(top[u] != top[v]){
        if(depth[top[u]] < depth[top[v]]) swap(u, v);
        res += query(1, id[top[u]], id[u]);
        u = fa[top[u]];
    }

    if(depth[u] < depth[v]) swap(u, v);
    res += query(1, id[v], id[u]);
    return res;
}

void modify_tree(int u, int k)
{
    modify(1, id[u], id[u] + sz[u] - 1, k);
}

LL query_tree(int u)
{
    return query(1, id[u], id[u] + sz[u] - 1);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    for(int i = 1; i <= n; i ++)
        cin >> a[i];

    memset(h, -1, sizeof(h));
    for(int i = 0; i < n - 1; i ++){
        int a, b;
        cin >> a >> b;
        add(a, b);
    }

    dfs1(1, -1, 1);//确定重边
    dfs2(1, 1);//确定dfs序
    build(1, 1, n);
    
    cin >> m;
    while(m --){
        int op, u, v, k;
        cin >> op;
        if(op == 1){
            cin >> u >> v >> k;
            modify_path(u, v, k);
        }else if(op == 2){
            cin >> u >> k;
            modify_tree(u, k);
        }else if(op == 3){
            cin >> u >> v;
            cout << query_path(u, v) << endl;
        }else{
            cin >> u;
            cout << query_tree(u) << endl;
        }
    }

    return 0;
}
~~~



***



## 动态树

- 思想：按照实边和虚边划分边，每个点一定在实边组成的链中，单个点自成链，每条实边链用一颗splay维护

- tips:

  - 边权变点权技巧
    - 在两点之间插入一个点，并把边权赋在这个点上即可。

- LCT七大操作

  ![lct1](.images/lct1.jpg)



​		![lct2](.images/lct2.jpg)



```c++
/*
AcWing2539.动态树
给定 n 个点，编号从 1 到 n，其中第 i 个点的初始权值为 ai。

现在要对这些点进行 m 次操作，操作共分为以下 4 种：

0 x y，表示询问点 x 到点 y 之间的路径上的所有点（包括两端点）的权值的异或和。保证 x 和 y 之间存在连通路径。
1 x y，表示在点 x 和点 y 之间增加一条边 (x,y)。注意：如果两点已经处于连通状态，则无视该操作。
2 x y，表示删除边 (x,y)。注意：如果该边不存在，则无视该操作。
3 x w，表示将点 x 的权值修改为 w。
数据范围
1≤n≤10^5,
1≤m≤3×10^5,
1≤x,y≤n,
x≠y,
1≤ai,w≤10^9
*/

#include <bits/stdc++.h>

#define endl '\n'

using namespace std;

const int N = 100010;
struct node{
    int s[2], v, p;
    int rev, sum;
}tr[N];
int stk[N];
int n, m;

void pushrev(int x)
{
    tr[x].rev ^= 1;
    swap(tr[x].s[0], tr[x].s[1]);
}

void pushup(int x)
{
    tr[x].sum = tr[tr[x].s[0]].sum ^ tr[x].v ^ tr[tr[x].s[1]].sum;
}

void pushdown(int x)
{
    if(tr[x].rev){
        pushrev(tr[x].s[0]), pushrev(tr[x].s[1]);
        tr[x].rev = 0;
    }
}

bool is_root(int x)
{
    return x != tr[tr[x].p].s[0] && x != tr[tr[x].p].s[1];
}

//splay函数
void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = x == tr[y].s[1];
    if(!is_root(y)) tr[z].s[y == tr[z].s[1]] = x;
    tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[y].p = x, tr[x].s[k ^ 1] = y;
    pushup(y), pushup(x);
}

void splay(int x)
{
    //这里splay的时候，可能根到x路径上的懒标记没有传下来
    //要先传懒标记
    int top = 0, r = x;
    stk[++ top] = x;
    while(!is_root(r)) stk[++ top] = r = tr[r].p;
    while(top) pushdown(stk[top --]);
    while(!is_root(x)){
        int y = tr[x].p, z = tr[y].p;
        if(!is_root(y))
            if((x == tr[y].s[1]) ^ (y == tr[z].s[1])) rotate(x);
            else rotate(y);
        rotate(x);
    }
}

//LCT函数
void access(int x)//建立一条x到根的实边路径， 同时把x旋转到splay的根节点
{   
    int z = x;
    for(int y = 0; x; y = x, x = tr[x].p){
        splay(x);
        tr[x].s[1] = y, pushup(x);
    }
    splay(z);
}

void make_root(int x)//将x变为整棵树的根节点, 同时把x旋转到splay的根节点
{
    access(x);
    pushrev(x);
}

int find_root(int x)//找到x所在树的根节点，并把根节点旋转到spaly的根节点
{
    access(x);
    while(tr[x].s[0]) pushdown(x), x = tr[x].s[0];
    splay(x);
    return x;
}

void split(int x, int y)//建立x到y的实边路径，并且y是splay的根节点
{
    make_root(x);
    access(y);
}

void link(int x, int y)//如果x,y之间没有边，就加一条x到y的虚边
{
    make_root(x);
    if(find_root(y) != x) tr[x].p = y;
}

void cut(int x, int y)//切掉x,y之间的边
{
    make_root(x);
    access(y);
    if(find_root(y) == x && tr[x].s[1] == y && !tr[y].s[0])
        tr[x].s[1] = tr[y].p = 0, pushup(x);
}

int main()
{   
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        cin >> tr[i].v;

    while(m --){
        int op, x, y;
        cin >> op >> x >> y;
        if(op == 0){
            split(x, y);
            cout << tr[y].sum << endl;
        }else if(op == 1) link(x, y);
        else if(op == 2) cut(x, y);
        else{
            splay(x);
            tr[x].v = y;
            pushup(x);
        }
    }

    return 0;
}
```



***



## 点分治

- 思想
  - 按照树的重心进行划分，对重心连接的每个子树进行处理
  - 性质：按照重心划分出来的子树大小不会超过总点数的一半
- 时间复杂度
  - 一共$logn$层，总复杂度为$logn$ * 每一层的复杂度

```c++
/*
AcWing 252.树
给定一个有 N 个点（编号 0,1,…,N−1）的树，每条边都有一个权值（不超过 1000）。

树上两个节点 x 与 y 之间的路径长度就是路径上各条边的权值之和。

求长度不超过 K 的路径有多少条。
数据范围
1≤N≤10^4,
1≤K≤5×10^6,
0≤l≤10^3
*/

#include <bits/stdc++.h>

using namespace std;

const int N = 10010, M = N << 1;
int h[N], e[M], w[M], ne[M], idx;
bool st[N];
int n, k;

void add(int a, int b, int c)
{
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
	e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++;
}

int get_size(int u, int fa)
{
	if(st[u]) return 0;
	int sum = 1;
	for(int i = h[u]; ~i; i = ne[i]){
		int ver = e[i];
		if(ver == fa) continue;
		sum += get_size(ver, u);
	}
	return sum;
}

int get_wc(int u, int fa, int tot, int &wc)//找到u为根的子树的重心
{
	if(st[u]) return 0;
	int sum = 1, mx = 0;
	for(int i = h[u]; ~i; i = ne[i]){
		int ver = e[i];
		if(ver == fa) continue;
		int t = get_wc(ver, u, tot, wc);
		sum += t;
		mx = max(mx, t);
	}
	mx = max(mx, tot - sum);
	if(mx <= tot / 2) wc = u;
	return sum;
}

void get_dist(int u, int fa, int dist, vector<int> &vec)
{
	if(st[u]) return;
	vec.push_back(dist);
	for(int i = h[u]; ~i; i = ne[i]){
		int ver = e[i];
		if(ver == fa) continue;
		get_dist(ver, u, dist + w[i], vec);
	}
}

int get_ans(vector<int> &vec)
{
	sort(vec.begin(), vec.end());
	int res = 0;
	for(int i = vec.size() - 1, j = -1; i >= 0; i --){
		while(j + 1 < i && vec[j + 1] + vec[i] <= k) j ++;
		j = min(j, i - 1);
		res += j + 1;
	}

	return res;
}

int calc(int u)//计算以u为根的子树内符合条件的线段数量
{
	if(st[u]) return 0;
	get_wc(u, -1, get_size(u, -1), u);
	st[u] = true;//u此时就是重心

	int res = 0;
	vector<int> p;//所有节点到重心的距离
	for(int i = h[u]; ~i; i = ne[i]){
		int ver = e[i];
		vector<int> q;//当前子树到重心的距离
		get_dist(ver, u, w[i], q);
		for(auto c : q){
			if(c <= k) res ++;
			p.push_back(c);
		}
		res -= get_ans(q);
	}
	res += get_ans(p);

	for(int i = h[u]; ~i; i = ne[i]) res += calc(e[i]);

	return res;
}

void solve()
{
	idx = 0;
	memset(h, -1, sizeof(h));
	memset(st, 0, sizeof(st));
	for(int i = 0; i < n - 1; i ++){
		int a, b, c;
		cin >> a >> b >> c;
		add(a, b, c);
	}

	cout << calc(1) << "\n";
}	

int main()
{	
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	while(cin >> n >> k, n || k) solve();

	return 0;
}
```



***

## CDQ分治

- 解决问题：解决三维偏序问题
- 思想

  - 按照三关键字排序，这样对于每一个数符合条件的一定在其前面
  - 每一个递归例程是求解这一例程对应对应区间内所有元素满足要求的对应的元素数量
  - 对于一个区间，一分为二，左右分别递归，各自区间得到求解，但对于右半区间，左边区间对其产生的贡献还未统计，此时归并求解
  - 归并方法：左半区间第一关键字一定已满足要求，且两区间内元素都按第二关键字排序(递归的副作用)，双指针统计右半边区间内每个元素在左区间内第二关键字满足的最大元素位置，两指针都往右走不会回头，同时用树状数组记录左半区间第三关键字的情况，对于右半区间每个元素，左区间内元素都到相应位置时(意味着，第一、第二关键字都已满足)，在树状数组中查询第三关键字满足要求的元素数量即可


- 时间复杂度：$O(n * log(n)^2)$

  ```c++
  /*
  给定 n 个元素（编号 1∼n），其中第 i 个元素具有 ai,bi,ci 三种属性。
  设 f(i) 表示满足以下 4 个条件：
  aj≤ai
  bj≤bi
  cj≤ci
  j≠i
  的 j 的数量。
  对于 d∈[0,n)，求满足 f(i)=d 的 i 的数量。
  
  数据范围
  1≤n≤10^5,
  1≤ai,bi,ci≤k≤2×10^5
  */
  
  #include <bits/stdc++.h>
  
  using namespace std;
  
  const int N = 100010, M = N << 1;
  struct data{
  	int a, b, c, s, res;
  
  	bool operator< (const data &t) const
  	{
  		if(a != t.a) return a < t.a;
  		if(b != t.b) return b < t.b;
  		return c < t.c;
  	}
  
  	bool operator== (const data &t) const
  	{
  		return a == t.a && b == t.b && c == t.c;
  	}
  }q[N], tmp[N];
  int tr[M], ans[N];
  int n, m;
  
  int lowbit(int x)
  {
  	return x & -x;
  }
  
  void add(int x, int c)
  {
  	for(int i = x; i <= m; i += lowbit(i)) tr[i] += c;
  }
  
  int sum(int x)
  {
  	int res = 0;
  	for(int i = x; i; i -= lowbit(i)) res += tr[i];
  	return res;
  }
  
  void merge_sort(int l, int r)
  {
  	if(l >= r) return;
  	int mid = l + r >> 1;
  	merge_sort(l, mid), merge_sort(mid + 1, r);
  
  	int i = l, j = mid + 1, k = 1;
  	while(i <= mid && j <= r)
  		if(q[i].b <= q[j].b) add(q[i].c, q[i].s), tmp[k ++] = q[i ++];
  		else q[j].res += sum(q[j].c), tmp[k ++] = q[j ++];
  	while(i <= mid) add(q[i].c, q[i].s), tmp[k ++] = q[i ++];
  	while(j <= r) q[j].res += sum(q[j].c), tmp[k ++] = q[j ++];
  
  	//清空树状数组
  	for(int i = l; i <= mid; i ++) add(q[i].c, -q[i].s);
  
  	for(int i = l, j = 1; i <= r;) q[i ++] = tmp[j ++];
  }
  
  int main()
  {
  	ios::sync_with_stdio(false);
  	cin.tie(nullptr);
  
  	cin >> n >> m;
  	for(int i = 1; i <= n; i ++){
  		int a, b, c;
  		cin >> a >> b >> c;
  		q[i] = {a, b, c, 1};
  	}
  	sort(q + 1, q + 1 + n);
  	
  	//去重、统计数量
  	int k = 2;
  	for(int i = 2; i <= n; i ++)
  		if(q[i] == q[k - 1]) q[k - 1].s ++;
  		else q[k ++] = q[i];
  
  	merge_sort(1, k - 1);	
  
  	for(int i = 1; i < k; i ++)
  		ans[q[i].res += q[i].s - 1] += q[i].s;
  
  	for(int i = 0; i < n; i ++)
  		cout << ans[i] << "\n";
  
  	return 0;
  }
  ```

  

## AC自动机

用于解决多模式匹配问题，例如 很多个单词在一篇文章中出现了多少个

时间复杂度$O(n)$, n为文章长度

ne[]存储每个节点最大后缀相匹配的最大前缀

```c++
acwing 1282题
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 10010, M = 1000010, S = 51;
int tr[N * S][26], cnt[N * S], idx;
int q[N * S], ne[M];

void insert(char str[])
{
    int p = 0;
    for(int i = 0; str[i]; i ++){
        int t = str[i] - 'a';
        if(!tr[p][t]) tr[p][t] = ++ idx;
        p = tr[p][t];
    }
    cnt[p] ++;
}
//按照层来算， 已知i - 1层信息，算第i层信息，bfs
void build()
{
    int hh = 0, tt = -1;
    for(int i = 0; i < 26; i ++)
        if(tr[0][i])
            q[++ tt] = tr[0][i];
    
    while(hh <= tt){
        int t = q[hh ++];
        for(int i = 0; i < 26; i ++){
            //int c = tr[t][i];
            //if(!c) continue;
            //int j = ne[t];
            //while(j && !tr[j][i]) j = ne[j];//找到有孩子i的节点
            //if(tr[j][i]) j = tr[j][i];
            //上面这一步可以优化，这段的核心是找到带有i的并且父节点是t的
            //需要反复向上跳，优化的手段就是如果没有i这个孩子，就让它等于tr[ne[t]][i]
            //这相当于记录了最终要跳的位置
            //可优化成如下,这一步优化了，下面查找也要优化
            // 可以理解为：本来要去找应该跳到哪，不存在才需要找，直接利用这空间存储应该跳到哪
            int p = tr[t][i];
            if(!p) tr[t][i] = tr[ne[t]][i];
            else{
                ne[p] = tr[ne[t]][i];
                q[++ tt] = p;
            }
            
            
            ne[c] = j;
            q[++ tt] = c;
        }
    }
}

int main()
{
    int T;
    scanf("%d", &T);
    while(T --){
        memset(tr, 0, sizeof tr);
        memset(cnt, 0, sizeof cnt);
        memset(q, 0 ,sizeof q);
        
        int n;
        scanf("%d", &n);
        
        char str[M];
        
        for(int i = 0; i < n; i ++){
            scanf("%s", str);
            insert(str);
        }
        
        build();
        
        int res = 0;
        scanf("%s", str);
        
        //匹配，j记录当前文本串中以str[i - 1]结尾的最大匹配
        for(int i = 0, j = 0; str[i]; i ++){
            int t = str[i] - 'a';
            //while(j && !tr[j][t]) j = ne[j];
            //if(tr[j][t]) j = tr[j][t];
            //建立优化以后，这里可以优化成
            j = tr[j][t];
            
            int p = j;
            while(p){
                res += cnt[p];
                cnt[p] = 0;
                p = ne[p];
            }
        }
        
        printf("%d\n", res);
    }
    
    return 0;
}
```





## 堆

```c++
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;//注意这里只能写成h[t],t一直记录的最小值
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

## 哈希表

按存储结构分：拉链法， 开放寻址法

```c++

(1) 拉链法//h[N]表示哈希数组，其中每一个值都是一个小链表头
    //e[N]用来存储所有的值
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool query(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }
(2) 开放寻址法
    int h[N];//通常开题目数据的两到三倍
	//初始要对h数组中数字的标记
	memset(h, 0x3f, sizeof(h));

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int k = (x % N + N) % N;
        while (h[k] != null && h[k] != x)//null为标记数字
        {
            k ++ ;
            if (k == N) k = 0;
        }
        return k;
    }
```



## 字符串哈希

思想：通过求每一段字符串的前缀数字表示，进而得出每一段字符串的数字表示

```c++
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];//str[i]转化成数字不能等于0
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

***



## 字符串的最小表示

对于一个长度为$n$字符串，把其看成一个环, 从任意一个字符开始的长度为$n$的所有字符串的，字典序最小的就是其最小表示

$O(n)$

```c++
string getMin(string str)
{
    int n = str.size();
    str = str + str;

    int i = 0, j = 1;
    while(i < n && j < n){
        int k = 0;
        while(str[i + k] == str[j + k]) k ++;
        if(k == n) break;//循环节，且以循环一轮
        if(str[i + k] > str[j + k]) i += k + 1;
        else j += k + 1;
        if(i == j) j ++;
    }
    int k = min(i, j);
    string res = str.substr(k, n);
    return res;
}
```





# 三、搜索与图论



## BFS与DFS

**BFS**

使用队列，while循环里对头元素四顾，出队，反复直至队列空

基于迭代，不会爆栈，每次搜索到的含有“最小”性质

- flood fill模型

  找连通块，每次搜索把联通的全部标记，不会重复搜索 复杂度O(n)

- 最短路模型

找最短步数类的题，每步花费一样，由于bfs的性质每次找到一个点都是到这个点的最短步数

一种最短步数模型是把每一种变化结果作为一个点， 如果一种状态A能变换成另一种状态B，B就可以由A扩展出来

- 多源最短路

求每一个特定点到多个终点中最短的最短距离，从所有终点开始bfs,每次扩展出来的点，就是终点这个点的最短距离（这里可以把所有终点想象成一个点）这里多个终点就变成了搜索的源点，即多源

- 双端队列广搜

应用于所有正权值相同，但含有0权值的最短路径，A搜到B，AB两个点间权值为0，说明AB属于同一层，应该把B加到队头，若AB间权值大于0，则B应该属于下一层，B加到队尾，这相当于不能把同一层的一次性搜完再搜下一层，（这里一层的点只会由上一层或同一层的点搜到，换句话说一个点只能搜到同层或下一层的点）同时，   搜索的过程中可能搜到同一层的也可能搜到下一层的。

```c++
/*
AcWing 4481. 方格探索
给定一个 n 行 m 列的方格矩阵。行坐标从上到下为 1∼n，列坐标从左到右为 1∼m。

其中的每个方格，要么是空格（用 . 表示），要么包含障碍物（用 * 表示）。

初始时，一个人位于第 r 行第 c 列的空格之中。

他可以沿上下左右四个方向进行移动，每次移动一格距离。

对于他的移动，有如下限制：

他不能进入到包含障碍物的方格中，也不能走出矩阵的边界。
在整个移动过程中，他向左移动的总次数不能超过 x 次。
在整个移动过程中，他向右移动的总次数不能超过 y 次。
请问，一共有多少个空格是此人可以抵达的？

注意，初始空格视为此人可达。
n <= 2000
*/

#include <bits/stdc++.h>

using namespace std;
using PII = pair<int, int>;

const int N = 2010;
char g[N][N];
int n, m, r, c, a, b;
int dist[N][N];
bool st[N][N];

int bfs(int r, int c)
{
    memset(dist, 0x3f, sizeof(dist));
    dist[r][c] = 0;
    deque<PII> dq;
    dq.push_back({r, c});

    int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0 ,-1, 1};
    int res = 0;
    while(dq.size()){
        auto t = dq.front();
        dq.pop_front();
        int x = t.first, y = t.second;

        if(st[x][y]) continue;
        else{
            if(dist[x][y] <= b && dist[x][y] - (y - c) <= a) res ++;
        }

        st[x][y] = true;

        for(int i = 0; i < 4; i ++){
            int nx = x + dx[i], ny = y + dy[i];

            if(nx < 1 || nx > n || ny < 1 || ny > m || g[nx][ny] == '*') continue;
            if(i == 3){
                dist[nx][ny] = min(dist[nx][ny], dist[x][y] + 1);
                dq.push_back({nx, ny});
            }else{
                dist[nx][ny] = min(dist[nx][ny], dist[x][y]);
                dq.push_front({nx, ny});
            }
        }
    }

    return res;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m >> r >> c >> a >> b;
    for(int i = 1; i <= n; i ++)
        cin >> g[i] + 1;

    cout << bfs(r, c) << "\n";

    return 0;
}
```



双向广搜

搜索的中间状态可能过多，从起点直接往终点搜会爆复杂度，因此，从起点和终点同时搜，两个搜索同时搜到一个中间态即可得到答案，若搜索过程中有一个队列变空，说明无解。例题 acwing190字符变换

A*算法

用于从起点到终点状态过多的情况，无解时A*会很慢

为每一个状态添加估计函数，估计函数必须非负，估计当前状态到终点的距离，每次选择队列中当前距离加估计距离最小的状态进行扩展，（这里用优先队列，注意要定义成小根堆）

终点状态出队时一定是最优的，也就是最短距离 注意：估计函数值f()一定要小于等于当前状态到终止状态的实际最优值g()，第一次出队取到最小距离只对终点成立，每个点可能入队多次

证明（解存在时）：从起点开始扩展，扩展的状态里一定有最优路径上的状态，最优路径上的状态一定会再扩展出最优路径上的状态，即队列中每时每刻都存在最优路径上的状态u, 假设当终止状态出队时不是最优解，dist(终止)> dist(最优)，则队列中一定存在最优路径上的状态u，

dsit(u) + f(u) <= dist(u) + g(u) = dist(最优) < dist(终止) 这与队列每次出队当前实际距离加估计距离的最小值矛盾，故终止状态出队时一定为最优



**DFS**

通常写成递归，用系统栈，若爆栈，则需要改成非递归，若有一递归分支是无条件的则必须return，

通常是满足答案则输出，否者递归搜索



dfs与连通性

dfs也可以找连通块，但只能知道是否联通，并不知道到每个点的最短距离；

dfs的搜索顺序

在保证能搜到最优解的同时做适当的优化（剪枝）

dfs剪枝

1、优化搜索顺序

大部分情况下，优先搜索分支较少的节点，此时会得到解，以后搜索分支较多的节点时，其更容易被最优性剪枝剪掉

2、排除等效冗余，列入有的应该按照组合数搜索，不应该按照排列数搜索，因为不考虑组内顺序，此时搜索时加入搜索顺序，可以排除大量等效冗余

3、可行性剪枝，当前搜索已经不满足题目要求，方案不可行，直接返回即可

4、最优性剪枝，当前搜索所能找到的解大于等于当前搜到的答案，即当前搜索不能更新最优解，直接返回即可

dfs迭代加深

问题的解在比较浅的层次，但可能会搜到很深的层次，因此，定义一个最大的搜索深度，若在此深度内未搜到解，则深度加深后从新搜索，可以这样做的原因是，搜索树最后一层的节点数量比前面所有层的节点数量加起来要多

双向dfs

空间换时间，先打表部分要搜索的，把所有可能的结果存在表中，只搜索另一部分，另一部分搜索完成后，再去表中查，与搜索的结果拼成答案，然后查看是否能更新最优解

IDA*

迭代加深+全局最优性剪枝，每次定义一个最大搜索深度，同时有一个估计函数，估计当前能否在目前的最大深度内搜到解，所估计的值大于当前最大深度直接返回

## 拓扑排序

没有回向边

核心思想：先找到入度为0的点，入队，把其去掉后，其所连接的点入读减减，减到0后表示其其前面的点已经完成，不必回向，入队，

因此入队顺序就是拓扑序列

```c++
void bfs()
{
    queue<int> Q;
    for(int i = 1; i <= n; i ++)
        if(d[i] == 0) {
            Q.push(i);//Q是遍历队列
            ans.push(i);//ans是答案队列
        }
    
    while(!Q.empty()){
        int t = Q.front(); Q.pop();
        for(int i = h[t]; i != -1; i = ne[i]){
            int j = e[i]; d[j] --;
            if(d[j] == 0){
            Q.push(j); ans.push(j);
            }    
        }
    }    
}
```

## 最短路

最短路可能还有乘法，对于所有乘数大于0的情况，若乘数都小于1，相当于正权图，若乘数有的大于1，有的小于1，则只能用spfa，相当于含有负权图

因为小于1时每确定一个点的最大值，后面的路径都不能使它变的更大

- 朴素$dijkstra$ : 用于单源正权值最短路，稠密图，邻接矩阵存储、

此算法关注点在点

时间复杂是 $O(n^2+m) $, $n$表示点数，$m$ 表示边数

```c++
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool flag[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!flag[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t}[j]);

        flag[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

```



- 堆优化版$dijkstra$

邻接表存储，稀疏图

时间复杂度 $O(mlogn)$ $n$ 表示点数，$m$ 表示边数


```c++
typedef pair<int, int> PII;

int n; // 点的数量
int h[N], w[N], e[N], ne[N], idx;// 邻接表存储所有边
int dist[N];// 存储所有点到1号点的距离
bool flag[N];// 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});// first存储距离，second存储节点编号
while (heap.size())
{
    auto t = heap.top();
    heap.pop();

    int ver = t.second, distance = t.first;

    if (flag[ver]) continue;
    flag[ver] = true;

    for (int i = h[ver]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (dist[j] > distance + w[i])
        {
            dist[j] = distance + w[i];
            heap.push({dist[j], j});
        }
    }
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```

$dijkstra$的核心是：先找到距离始点最近的点（初始为始点本身），然后用此点更新与其相连的点的距离。



- $bellmanFord$ : 适用于有负权边,此算法关注点在边，可以求有边的限制的最短路

每次更新点可能会有连锁反应，一次更新了好多点，这与边的顺序有关，可能会提前得到所有点的最短路，但依赖边的顺序，因此保证解的正确要更新$n$次，因此最坏$n$全部正确更新

时间复杂度$O(n*m)$

```c++
nt n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }
	//因为无脑更新所有边，所以，就算到不了也可能让其dist比0x3f3f3f3f小，而spfa更新所有已经更新的点的边，所以，到不了的点不会被更新
    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```



- spfa 算法（队列优化的$BellmanFord$算法）

优化原理是只有当前点距离变小才会更新与其相连的点，因此，把所有距离变小的点入队

时间复杂度 平均情况下 $O(m)$，最坏情况下 $O(n*m)$, $n$ 表示点数，$m$ 表示边数

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

```


- spfa找负环

时间复杂度是 $O(n*m)$, $n$ 表示点数，$m$ 表示边数

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组，因为如果存在负环，其到始点的距离一定会变负
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。
    //所有点入队，是因为从某些点可能走不到负环，因此cnt表示的是每个联通域，其他各点到联通域起点走过的边数
    //负环上的点会反复入队
    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环（因为共只有n个点）
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```



- floyd算法：用于求多源汇最短路问题，思想是基于动态规划

任意两个点的之间的所有通路都会被遍历到，任取任意两点s,e之间的一条通路，通路上的点都会作为中间点，以更新其他两点之间距离，最终会更新到s，e两点之间的距离

时间复杂度是 $O(n^3)$, n 表示点数

```c++
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

```

- floyd算法应用，求传递闭包，最小环，恰好经过k条边的最短距离（对floyd进行变形）



****



## 最小生成树

- 朴素版prim算法 

稠密图，邻接矩阵

 Prim算法求最小生成树
时间复杂度是 $O(n^2+m)$, n 表示点数，m 表示边数

思想：每次找到当前距离连通域最小的点，再用这个点去更新其他点到连通域的距离


```c++
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool flag[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    //循环n次是因为从第一个点开始加入集合
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!flag[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
//如果当前不是第一个点，且到联通域距离为无穷大，则其不联通
        if (i && dist[t] == INF) return INF;
//不是第一个点，则更新边权和，要写在用t更新其他点到连通域距离的前面,因为t若有负自环，会把自己到连通域的距离再次更新，最小生成树不考虑自环
   
        if (i) res += dist[t];
        flag[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```



- $Kruskal$算法

稀疏图

时间复杂度是 $O(mlogm)$, $n$ 表示点数，$m$ 表示边数

思想：先把所有边从小到大排序，然后依次枚举每条边，若该边连接的两点不连通（并查集），就把该边加入到最小生成树中

```c++
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}

```



****



## 差分约束

对与一系列形如$x_i \leq x_j + c$的不等式，求每个变量的最小值或最大值

- 最小值
  - 使用最长路
  - 把每个不等式转化为上述形式，由$j$向$i$连一条长度为$c$的边
  - 负环判定有无解
- 最大值
  - 使用最短路
  - 把每个不等式转化为上述形式，由$i$向$j$连一条长度为$-c$的边
  - 正环判定有无解
- $spfa$正负环判定
  - 判定每个点的被更新次数是否大于等于总点数即可，大于即存在正负环
  - 优化技巧：可尝试把队列改为栈
  - 若没有一个点存在一个路径到达其余所有点，可无脑初始直接把所有点入队\栈

```c++
/*
幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。
如果 X=1．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。
如果 X=2，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。
如果 X=3，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。
如果 X=4，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。
如果 X=5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。
*/

#include <bits/stdc++.h>

using namespace std;
using LL = long long;
constexpr int N = 100007;
constexpr int M = 300007;
int h[N], e[M], w[M], ne[M], idx;
int q[N], cnt[N];
LL d[N];
bool st[N];
int n, m;

void add(int u, int v, int c)
{
    e[idx] = v, w[idx] = c, ne[idx] = h[u], h[u] = idx ++;
}

bool spfa()
{
    memset(d, -0x3f, sizeof(d));
    d[0] = 0;
    int tt = 1;
    q[1] = 0;

    while(tt){
        int t = q[tt --];
        st[t] = false;

        for(int i = h[t]; ~i; i = ne[i]){
            int ver = e[i];
            if(d[ver] < d[t] + w[i]){
                d[ver] = d[t] + w[i];
                cnt[ver] = cnt[t] + 1;
                if(cnt[ver] >= n + 1) return false;
                if(!st[ver]){
                    q[++ tt] = ver;
                    st[ver] = true;
                }
            }
        }
    }

    return true;
}

void sovle()
{   
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    for(int i = 1; i <= m; i ++){
        int t, a, b;
        cin >> t >> a >> b;
        if(t == 1){
            add(a, b, 0), add(b, a, 0);
        }else if(t == 2){
            add(a, b, 1);
        }else if(t == 3){
            add(b, a, 0);
        }else if(t == 4){
            add(b, a, 1);
        }else{
            add(a, b, 0);
        }
    }

    for(int i = 1; i <= n; i ++)
        add(0, i, 1);

    if(spfa()){
        LL res = accumulate(d + 1, d + 1 + n, 0ll);
        cout << res << "\n";
    }else {
        cout << -1 << "\n";
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setiosflags(ios::fixed) << setprecision(2);
    int T = 1;
    //cin >> T;
    while(T --){
        sovle();
    }

    return 0;
}
```







## 最近公共祖先（$lca$）

- 倍增求$lca$模板

~~~c++
//设置哨兵0号点，fa[0][j] = 0, depth[0] = 0, 因此根节点depth为1
int depth[N];
int fa[N][k];//k的范围依据数据范围而定，2^k < N, 离N最进的k
//预处理fa[i][j]表示从i跳2^j步跳到哪里
void bfs()
{
    memset(depth, 0x3f, sizeof(depth));
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    q[0] = 1;

    while(hh <= tt){
        int t = q[hh ++];
        for(int i = h[t]; ~i; i = ne[i]){
            int ver = e[i];
            if(depth[ver] > depth[t] + 1){
                depth[ver] = depth[t] + 1;
                fa[ver][0] = t;
                for(int k = 1; k <= 16; k ++)
                    fa[ver][k] = fa[fa[ver][k - 1]][k - 1];
                q[++ tt] = ver;
            }
        }
    }
}

int lca(int u, int v)
{
    if(depth[u] < depth[v]) swap(u, v);
    for(int k = 16; k >= 0; k --)
        if(depth[fa[u][k]] >= depth[v])
            u = fa[u][k];
    if(u == v) return u;
    for(int k = 16; k >= 0; k --)
        if(fa[u][k] != fa[v][k]){
            u = fa[u][k];
            v = fa[v][k];
        }
    return fa[u][0];
}
~~~





- $tarjan$求$lca$

关于tarjan求lca的理解

对于每个节点$u$，我们求关于u的询问是在回溯到$u$的时候，设此时与$u$相关的询问节点是$v$，且$v$被标记成了$2$，即$v$已经被遍历完，因为$u \neq v$, 则$u$和$v$一定位于其最近公共祖先$lca$的两个分支，且$v$被标记成了$2$，而此时在遍历$u$说明从最近公共祖先出发，$v$所在的链已经被遍历完，$v$所在链上的节点，其并查集的代表元素都是$lca$，这一点可以证明，若标记成$lca$的祖先，因为此时遍历到$u$，但$lca$的所有子孙节点还没有遍历完，因此，不可能标记成$lca$的祖先。若标记成，$lca$的子孙节点$lcason$的话，则从$v$和$u$就是$lcason$的两个分支，这与$lca$是最近公共祖先矛盾，因此，$v$的表标记的一定是$lca$。

```c++
typedef pair<int, int> PII;
int h[N], e[M], w[M], ne[M], idx;
vector<PII> query[N];   // first存查询的另外一个点，second存查询编号
void tarjan(int u)
{
    st[u] = 1;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            tarjan(j);
            p[j] = u;
        }
    }

    for (auto item : query[u])
    {
        int y = item.first, id = item.second;
        if (st[y] == 2)
        {
            int anc = find(y);
            res[id] = dist[u] + dist[y] - dist[anc] * 2;//求出公共祖先要做的操作
        }
    }

    st[u] = 2;
}
```





***





## 有向图的强连通分量

- 联通分量：对于分量中的任意两点$u,v$, $u, v$可以互相走到
- 强联通分量：极大联通分量
- 求完$scc$后缩点，能把原图变为有向无环图$（DAG）$,强连通分量的倒序就是缩完点后图的拓扑排序

- 模板

~~~c++
//核心思想:每一个节点为根的子树，若dfn[u] == low[u]搜完其所有节点，此时栈中到u的点就是u所在的scc
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], sz[N], sccCnt;
bool inStk[N];
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[++ top] = u, inStk[u] = true;
    for(int i = h[u]; ~i; i = ne[i]){
        int ver = e[i];
        if(!dfn[ver]){
            tarjan(ver);
            low[u] = min(low[u], low[ver]);
        }else if(inStk[ver]) low[u] = min(low[u], dfn[ver]);
    }

    if(dfn[u] == low[u]){
        sccCnt ++;
        int ver;
        do{
            ver = stk[top --];
            inStk[ver] = false;
            id[ver] = sccCnt;
            sz[sccCnt] ++;
        }while(ver != u);
    }
}
~~~







## 无向图的双连通分量

- 边连通分量($edcc$)
  - 桥：对于一条边，如果把这条边去掉，图不连通，则这条边称为桥
  - 最大的不含桥的联通分量称为边联通分量


$tarjan$算法求$edcc$

```c++
//注意按照边搜索，所按照点来搜索（不回搜父亲即可）会被重边卡掉
//dfn[u] < low[j] 说明从u到j的这条边是桥边
//dfn[u] == low[u] 说明以u为根的子树是一个边连通分量
/*
对于一个无向图，至少加多少条边使其变成边联通分量
*/

constexpr int N = 5007;
constexpr int M = 10007;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], edccCnt;
bool isBridge[N];
int deg[N];
int n, m;

void add(int u, int v)
{
    e[idx] = v, ne[idx] = h[u], h[u] = idx ++;
}

void tarjan(int u, int from)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[++ top] = u;
    for(int i = h[u]; ~i; i = ne[i]){
        int ver = e[i];
        if(!dfn[ver]){
            tarjan(ver, i);
            low[u] = min(low[u], low[ver]);
            if(dfn[u] < low[ver]){
                isBridge[i] = isBridge[i ^ 1] = true;
            }
        }else if(i != (from ^ 1)) low[u] = min(low[u], dfn[ver]);
    }

    if(dfn[u] == low[u]){
        ++ edccCnt;
        int ver;
        do{
            ver = stk[top --];
            id[ver] = edccCnt;
        }while(ver != u);
    }
}

void sovle()
{   
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while(m --){
        int u, v;
        cin >> u >> v;
        add(u, v), add(v, u);
    }

    tarjan(1, -1);

    for(int i = 0; i < idx; i ++)
        if(isBridge[i]) deg[id[e[i]]] ++;

    int cnt = 0;
    for(int i = 1; i <= edccCnt; i ++)
        if(deg[i] == 1) cnt ++;
    cout << (cnt + 1) / 2 << "\n";
}
```



- 点连通分量($vdcc$)

$tarjan$求$vdcc$模板

```c++
//割点属于多个点连通分量，每个点连通分量都包含与其相关的所有割点
int stk[N], top;
int dfn[N], low[N], timestamp;
int  vdcc_cnt;
bool is_cut[N];//是否为割点
int root;
vector<int> sz[N];//存每一个edcc
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[++ top] = u;
    
    if(u == root && h[u] == -1){
        vdcc_cnt ++;
        sz[vdcc_cnt].push_back(u);
        return;
    }
    int cnt = 0;
    for(int i = h[u]; ~i; i = ne[i]){
        int j = e[i];
        if(!dfn[j]){
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if(dfn[u] <= low[j]){
                cnt ++;
                if (u != root || cnt > 1) is_cut[u] = true;
                ++ vdcc_cnt;
                int y;
                do{
                    y = stk[top --];
                    sz[vdcc_cnt].push_back(y);
                }while(y != j);
                sz[vdcc_cnt].push_back(u);
            }
        }else low[u] = min(low[u], dfn[j]);
    }
}
```







## 二分图

二分图定义：所有点在两个集合内，集合内的点之间没有边

一个图是二分图当且仅当图中不含奇数环

时间复杂度是 $O(n+m)$, n 表示点数，m 表示边数

```c++
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )//对每个点进行判断是为了防止图中含有多个连通域
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

匈牙利算法

找二分图的最大匹配

时间复杂度是 $O(n*m)$, n 表示点数，m 表示边数 实际运行远小于$O(n*m)$

思想：第一个集合中的点 i 与第二个集合中的点 j 相连，如果 j 还没有匹配 或者，可以调整与j匹配的点与其他点匹配，那么 i 就与 j 匹配

```c++
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool flag[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool dfs(int x)
{
    for(int i = h[x]; i != -1; i = ne[i]){
        int j = e[i];
        
        if(!flag[j]){
            flag[j] = true;
            if(!match[j] || dfs(match[j])){
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
    for(int i = 1; i <= n1; i ++){
        memset(flag, false, sizeof(flag));
        if(dfs(i)) res ++;
    }

```



匈牙利算法只需建从左部到右部的单向边，对左右部节点编号相不相同无限制

最小覆盖点：一张图中选出最少的点数使得所有边都至少与选出的一个点相连。

最大独立集：选出最多的点使得选出的点之间没有边。等价于选出最少的点，破坏所有的边。

以下两个针对有向无环图 (匈牙利算法都是用的无向图)

最小路径点覆盖：用最少的互不相交的路径将所有点覆盖。

最小路径重复点覆盖：用最少路径将所有点覆盖。原图求一遍传递闭包，得到新图后，在新图上求最小路径点覆盖

最大匹配数 = 最小覆盖点数 = 总点数 - 最大独立集数 = 总点数 - 最小路径点覆盖数





## 欧拉路径与欧拉回路

- 对于无向图，所有边都是连通的

  - 存在欧拉路径的充分必要条件：度数为奇数的点只能有$0$个或$2$个

  - 存在欧拉回路的充分必要条件：度数为奇数的点只能有$0$个

- 对于有向图，所有边都是连通的

  - 存在欧拉路径的充分必要条件是：要么所有点的出度等于入度，要么只有两个点出度不等于入度，一个点出度等于入度加一（起点），另一个点入度等于出度加一（终点）

  - 存在欧拉回路的充分必要条件：所有点的出度等于入度

- 统计方案

  - 统计点的方案时，按照出度统计，每出去一次，在这次搜索后把这个点加入方案中，这样统计终点最后不会被统计上，逆序后加上终点即可

```c++
//type == 1为无向图，反向边用负数表示， type等于2为有向图
const int N = 100010, M = 400010;
int h[N], e[M], ne[M], idx;
int din[N], dout[M];
int ans[M], cnt;
int type, n, m;
bool st[M];

void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

void dfs(int u)
{
    for(int &i = h[u]; ~i;){
        if(st[i]){
            i = ne[i];
            continue;
        }
        
        st[i] = true;
        if(type == 1) st[i ^ 1] = true;
        
        int t;
        if(type == 1){
            t = i / 2 + 1;
            if(i & 1) t = - t;
        }else t = i + 1;
        
        int j = e[i];
        i = ne[i];
        dfs(j);
        
        ans[++ cnt] = t;
    }    
}

int main()
{
    cin >> type >> n >> m;
    memset(h, -1, sizeof(h));
    for(int i = 0; i < m; i ++){
        int a, b;
        cin >> a >> b;
        add(a, b);
        if(type == 1) add(b, a);
        dout[a] ++, din[b] ++;
    }
    
    if(type == 1){
        for(int i = 1; i <= n; i ++)
            if((din[i] + dout[i]) & 1){
                cout << "NO" << "\n";
                return 0;
            }
    }else{
        for(int i = 1; i <= n; i ++)
            if(din[i] != dout[i]){
                cout << "NO" << "\n";
                return 0;
            }
    }
    
    for(int i = 1; i <= n; i ++)
        if(h[i] != -1){
            dfs(i);
            break;
        }
    
    if(cnt < m){
        cout << "NO" << "\n";
        return 0;
    }
    
    cout << "YES" << "\n";
    for(int i = cnt; i; i --)
        cout << ans[i] << ' ';
    
    return 0;
}
```





****



## 网络流

- 最大流基本概念

  ```c++
  1. 基本概念
      1.1 流网络，不考虑反向边
      1.2 可行流，不考虑反向边
          1.2.1 两个条件：容量限制、流量守恒
          1.2.2 可行流的流量指从源点流出的流量 - 流入源点的流量
          1.2.3 最大流是指最大可行流
      1.3 残留网络，考虑反向边，残留网络的可行流f' + 原图的可行流f = 原题的另一个可行流
          (1) |f' + f| = |f'| + |f|
          (2) |f'| 可能是负数
      1.4 增广路径
      1.5 割
          1.5.1 割的定义
          1.5.2 割的容量，不考虑反向边，“最小割”是指容量最小的割。
          1.5.3 割的流量，考虑反向边，f(S, T) <= c(S, T)
          1.5.4 对于任意可行流f，任意割[S, T]，|f| = f(S, T)
          1.5.5 对于任意可行流f，任意割[S, T]，|f| <= c(S, T)
          1.5.6 最大流最小割定理
              (1) 可行流f是最大流
              (2) 可行流f的残留网络中不存在增广路
              (3) 存在某个割[S, T]，|f| = c(S, T)
      1.6. 算法
          1.6.1 EK O(nm^2)
          1.6.2 Dinic O(n^2m)
      1.7 应用
          1.7.1 二分图
              (1) 二分图匹配
              (2) 二分图多重匹配
          1.7.2 上下界网络流
              (1) 无源汇上下界可行流
              (2) 有源汇上下界最大流
              (3) 有源汇上下界最小流
          1.7.3 多源汇最大流
  ```



- EK求最大流板子

  ```c++
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010, M = 20010, INF = 0x3f3f3f3f;
  int h[N], e[M], w[M], ne[M], idx;
  int maxc[N], pre[N];
  int q[N];
  bool st[N];
  int n, m, S, T;
  
  void insert(int a, int b, int c)
  {
      e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
      e[idx] = a, w[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
  }
  
  bool bfs()
  {
      memset(st, 0, sizeof(st));  
      int hh = 0, tt = 0;
      q[0] = S;
      maxc[S] = INF;
      st[S] = true;
      
      while(hh <= tt){
          int t = q[hh ++];
          for(int i = h[t]; ~i; i = ne[i]){
              int j = e[i];
              if(!st[j] && w[i]){
                  st[j] = true;
                  pre[j] = i;
                  maxc[j] = min(maxc[t], w[i]);
                  if(j == T) return true;
                  q[++ tt] = j;
              }
          }
      }
      
      return false;
  }
  
  int EK()
  {
      int res = 0;
      while(bfs()){
          res += maxc[T];
          for(int i = T; i != S; i = e[pre[i] ^ 1])
              w[pre[i]] -= maxc[T], w[pre[i] ^ 1] += maxc[T]; 
      }
      
      return res;
  }
  
  int main()
  {
      scanf("%d%d%d%d", &n, &m, &S, &T);
      
      memset(h, -1, sizeof(h));
      while(m --){
          int a, b, c;
          scanf("%d%d%d", &a, &b, &c);
          insert(a, b, c);
      }
      
      printf("%d\n", EK());
      
      return 0;
  }
  ```


- dinic求最大流板子

  ```c++
  理解：bfs建立分层图， 同时判断此时还有没有增广路径， 若还有增广路径， dfs找增广路径
  dfs的过程中当前弧优化理解：对于每个点可能存在多条路径走向终点，到达每个点时都有一个流量限制，这些限制的流量，通过这个点连接的各个边
  流向终点，若此时通过第一条边到达终点的流量限制小于当前限制说明这条边已经满流，以后再次搜索到这条边时，不必再搜，则把这个点可用的当前弧
  转向下一条边，以此类推，因此每个点的当前弧维护的是没有满流的边，dfs中flow < limit 为了维护这一性质加上这一语句
      
      
      
  #include <bits/stdc++.h>
  
  using namespace std;
  
  const int N = 10010, M = 200010, INF = 0x3f3f3f3f;
  int h[N], e[M], f[M], ne[M], idx;
  int d[N], cur[N], q[N];
  int n, m, S, T;
  
  void insert(int a, int b, int c)
  {
      e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
      e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
  }
  
  bool bfs()
  {
      memset(d, -1, sizeof(d));
      int hh = 0, tt = 0;
      q[0] = S, d[S] = 0, cur[S] = h[S];
      
      while(hh <= tt){
          int t = q[hh ++];
          
          for(int i = h[t]; ~i; i = ne[i]){
              int ver = e[i];
              if(d[ver] == -1 && f[i]){
                  d[ver] = d[t] + 1;
                  cur[ver] = h[ver];
                  if(ver == T) return true;
                  q[++ tt] = ver;
              }
          }
      }
      
      return false;
  }
  
  int dfs(int u, int limit)
  {
      if(u == T) return limit;
      
      int flow = 0;
      for(int i = cur[u]; ~i && flow < limit; i = ne[i]){
          cur[u] = i;
          int ver = e[i];
          if(d[ver] == d[u] + 1 && f[i]){
              int t = dfs(ver, min(f[i], limit - flow));
              if(!t) d[ver] = -1;
              f[i] -= t, f[i ^ 1] += t, flow += t;
          }
      }
      
      return flow;
  }
  
  int dinic()
  {
      int res = 0, flow;
      while(bfs()) while(flow = dfs(S, INF)) res += flow;
      return res;
  }
  
  int main()
  {   
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      
      cin >> n >> m >> S >> T;
      
      memset(h, -1, sizeof(h));
      while(m --){
          int a, b, c;
          cin >> a >> b >> c;
          insert(a, b, c);
      }
      
      cout << dinic() << endl;
      
      return 0;
  }
  ```

  

- 最大权闭合子图

  ```c++
  定义：选出一些点集，这些点所连的边只会连向选出的点，选出的有此性质的点成为闭合子图；
     
  解决的问题：给定一些点这些点的权值有正有负，选出一些点满足闭合子图的性质，这些点的权值最大就是最大权闭合子图。
  建图：所有正权值的点向源点连边，容量为点权值，所有负权值的点向汇点连边，容量为点权值的绝对值，其他边容量为正无穷。
  结论：选出的最大权闭合子图的值就是所有点权为正值的和减去最小割
  方案：从S开始搜，搜到的点就是所有选出来的点；
  ```


- 最大密度子图

  ```c++
  定义：选出一定的点，一定的边， 每条选出的边的端点都在选出的点集里面，使得边数除以点数最大
      
  解决的问题：（最一般化的问题）对于一个无向图，每个点有点权，每个边有边权，选出一些点和边， 使其满足最大密度子图的约束， 求使得选出的点权加边权除以点的个数取得最大值的选法和这个最大值
  建图：每个从源点连一条正向容量为U反向为0的边，向汇点连一条正向U + 2 * g - dg[i] - 2 * p[i]反向为0的边，其余边都是正反为边权
  结论：二分g, C[S, T] = U * n - （要最大化的式子 * 2）
  注意: U要使得2 * g - dg[i] - 2 * p[i] (dg[i] 为每个点连接的所有边的边权， p[i]为点权)，最大化的式子有g要二分
  ```


- 最小权覆盖集

  ```c++
  适用于二分图， 一般的图暴搜
  定义：对于一张二分图，每个点有权值，选出一些点，使得这些点的权值之和最小并且每条边的端点至少包含一个被选出的点（点权非负）
  解决的问题：同定义
  建图：二分图左边的点连向源点，右边的点连向汇点，容量为点权值， 中间点与点容量为INF；
  结论：最小割就是最小权覆盖
  如何找方案：先找出最小割，从S开始搜，沿着容量大于0的边搜，划分S, T集合，枚举正向边，若一条边容量为空 其为割边，这时判断起点在S集合还是T集合即可
  ```


- 最大独立集

  ```c++
  适用于二分图，一般图暴搜
  定义：对于一张无向图，每个点有权值，选出一些点，使得这些点之间没有边，并且点的权值之和最大
  解决的问题：同定义
  建图：同最小权覆盖
  结论：所有点的权值之和减去最小权覆盖
  ```

  

- 费用流

  ```c++
  定义：给定一个流网络，每条边除了有容量限制，还有单位流量费用，求最大流的最小费用或最大费用
  算法：SSP,就是把EK增广的函数换成spfa，按照边权是费用求最短路径
  核心思想：每次增广可行流，都用费用最便宜/最贵的边
   
  最小费用流模板：
      
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 5010, M = 100010, INF = 0x3f3f3f3f;
  int h[N], e[M], f[M], w[M], ne[M], idx;
  int d[N], pre[M], maxc[N], q[N];
  int n, m, S, T;
  bool st[N];
  
  void insert(int a, int b, int c, int d)
  {
      e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;
      e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
  }
  
  bool spfa()
  {
      memset(d, 0x3f, sizeof(d));
      memset(maxc, 0, sizeof(maxc));
      memset(st, 0, sizeof(st));
      int hh = 0, tt = 1;
      q[0] = S, d[S] = 0, maxc[S] = INF;
  
      while(hh != tt){
          int t = q[hh ++];
          if(hh == N) hh = 0;
          st[t] = false;
  
          for(int i = h[t]; ~i; i = ne[i]){
              int ver = e[i];
              if(f[i] && d[ver] > d[t] + w[i]){
                  d[ver] = d[t] + w[i];
                  pre[ver] = i;
                  maxc[ver] = min(maxc[t], f[i]);
                  if(!st[ver]){
                      q[tt ++] = ver;
                      if(tt == N) tt = 0;
                      st[ver] = true;
                  }
              }
          }
      }
  
      return maxc[T] > 0;
  }
  
  void EK(int &flow, int &cost)
  {
      flow = cost = 0;
      while(spfa()){
          int t = maxc[T];
          flow += t;
          cost += t * d[T];
          for(int i = T; i != S; i = e[pre[i] ^ 1])
              f[pre[i]] -= t, f[pre[i] ^ 1] += t;
      }
  }
  
  int main()
  {
      cin >> n >> m >> S >> T;
      memset(h, -1, sizeof(h));
      while(m --){
          int a, b, c, d;
          cin >> a >> b >> c >> d;
          insert(a, b, c, d);
      }
  
      int flow, cost;
      EK(flow, cost);
  
      cout << flow << ' ' << cost << endl;
  
      return 0;
  }
  ```

  





# 四、数学知识

## 数论

试除法判断质数 

时间复杂度 $O(\sqrt{n})$

```c++
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```

试除法分解质因数

时间复杂度 最坏$O(\sqrt{n})$

一个数最多只有一个大于sqrt(n)的质因数

```c++
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)//x中此时没有小于i的质因数
        {			//此式子成立，i中也不包含小于i的质因数 ,则i一定为质数
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

筛质数

欧拉筛（线性筛选）

时间复杂度$O(n)$

核心思想：一个数只被它的最小质因子筛掉

一个合数可以表示成一个最小质因子x乘以另一个数k，

分别枚举最小质数x和另一个数k把它们的乘积标记为合数,

此时如果k中也含有因数x，则停止，因为下一个质因子x与k相乘后的合数的最小质因子是上一个x

```c
int primes[N], cnt;     // primes[]存储所有素数
bool flag[N];         // flag[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!flag[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )//条件不用写 j <= cnt, 
        {											//i 为质数，primes[j] = i 时会停下来
            flag[primes[j] * i] = true;				//i为合数，primes[j] 为i最小质因子也会停下来
            if (i % primes[j] == 0) break;
        }
    }
}

```

线性筛选

思想：把每个质数的倍数筛选掉

时间复杂度$O( nlog(logn))$

```c++
int primes[N], cnt;     // primes[]存储所有素数
bool flag[N];         // flag[x]存储x是否被筛掉

void get_primes(int n)
{
    for(int i = 2; i <= n; i ++){
        if(!flag[i]){ 
            primes[cnt ++] = i;
            for(int j = i + i; j <= n; j += i) flag[j] = true;
        }
    }
}
```

试除法求所有约数

时间复杂度 $ O(\sqrt{n})$

约数成对出现，求小的即可

```c++
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```

约数个数和约数之和

```c++
如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)

```

欧几里得算法求最大公约数

```c++
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```



## 欧拉函数

定义：1~n中与n互质的数的个数

n分界质因数后 所有质因数为p1， p2，... ，pk;
$$
res = n * (1 - 1 / p1)(1 - 1 / p2)...(1 - 1/ pk);
$$
只与质因子有关，与质因子个数无关

```c++
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```

线性筛求欧拉函数

```c++
/*
质数i的欧拉函数等于i - 1

质数primes[j]乘以i的欧拉函数

1、若i % primes[j] == 0, 为primes[j] * phi(i)

2、若i % primes[j] != 0, 为（primes[j] - 1）* phi(i)

欧拉定理 若a 与 n互质 则 a ^ phi(n) mod n = 1
*/

int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉


void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```

## 快速幂

- 数的快速幂

求 m^k mod p，时间复杂度$ O(logk)$。

k的二进制表示u位是1就 乘以$m^{2^u}$次方

$m^{2^u}$等于$m^{2^{u-1}}$的平方，k算到下一位，也要相应的把这个数更新

```c++
求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```

快速幂求逆元，b与p（p是质数）互质 b的逆元为b^(p - 2);

- 矩阵快速幂

  $f[n] = f[0] * A ^ n;$ 

  A是一个矩阵，结合相邻两项的关系即可得到矩阵，注意矩阵中不能由变量

## 扩展欧几里得算法

裴蜀定理 ：对于任意正整数a, b， 一定存在非0正整数x, y使得
$$
ax + by = gcd（a，b）
$$


理解：a，b是gcd（a，b）的倍数，则a，b线性组合的正数也一定是gcd（a，b）的倍数，最小是一倍

```c++
int exgcd(int a, int b, int &x, int &y)
{
    if(!b){
        x = 1, y = 0;
        return a;
    } 
    
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    
    return d;
}
```

## 中国剩余定理

```c++
x 同余 a1 mod m1
x 同余 a2 mod m2
    .
    .
    .
    
x 同余 ak mod mk

    m1 m2...mk两两互质
    M = m1 * m2*...*mk
    Mi = M / mi
    ti是Mi模mi的乘法逆元
    x0 = a1 * M1 * t1 + a2 * M2 * t2 +...+ ak * Mk * tk;
	x 通解 x = x0 + k * M; 
```



## 求组合数

- 

$1≤n≤10000$
$1≤b≤a≤2000$

递归求解

总共只有$2000^2$中组合，预处理查表即可

时间复杂度$O(n^2)$

```c++
for(int i = 0; i < N; i ++)
        for(int j = 0; j <= i; j ++)
            if(!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```

- 

$1≤n≤10000$
$1≤b≤a≤10^5$

预处理出每个组合数会超时，此时按照组合数的定义求，预处理出每个数的阶乘和每个数阶乘的逆元(都是取余后的结果)

注意：$(a / b) mod p != (a mod p) / (b mod p)$,但b化为逆元后就可以先分别取余再相乘，因为化为逆元后除法变为乘法

时间复杂度$O(nlogn$)

```c++
首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p)    // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```

- 

$1≤n≤20$
$1≤b≤a≤10^{18}$
$1≤p≤10^5$

时间复杂度$O(logp(n) * p * logp)$

```c
若p是质数，则对于任意整数 1 <= m <= n，有：
    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)
C(n % p, m % p)直接算，C(n / p, m / p) (mod p)继续用lucas定理
int qmi(int a, int k, int p)  // 快速幂模板
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b, int p)  // 通过定理求组合数C(a, b)
{
    if (a < b) return 0;

    LL x = 1, y = 1;  // x是分子，y是分母
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        x = (LL)x * i % p;
        y = (LL) y * j % p;
    }

    return x * (LL)qmi(y, p - 2, p) % p;
}

int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```

- 

把最终的结果不取余，输出出来

```c++
当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
    1. 筛法求出范围内的所有质数
    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...
    3. 用高精度乘法将所有质因子相乘

int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉


void get_primes(int n)      // 线性筛法求素数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}


int get(int n, int p)       // 求n！中的次数
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}


vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }

    return c;
}

get_primes(a);  // 预处理范围内的所有质数

for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);



```

## 卡特兰数

$$
\frac{C^{n}_{2 * n}}{n + 1}
$$



给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0 的个数都不少于1 的个数的序列,数量就是卡特兰数



## 高斯消元

```c++
const int N = 110;
const double eps = 1e-6;
double a[N][N];
int n;

int gauss()
{
    int r, c;
    for(r = 0, c = 0; c < n; c ++){
        int t = r;
        for(int i = r + 1; i < n; i ++)
            if(fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
                
        if(fabs(a[t][c]) < eps) continue;
        
        for(int i = 0; i < n + 1; i ++) swap(a[t][i], a[r][i]);
        for(int i = n; i >= c; i --) a[r][i] /= a[r][c];
        for(int i = r + 1; i < n; i ++)
            if(fabs(a[i][c]) > eps)
                for(int j = n; j >= c; j --){
                    a[i][j] -= a[r][j] * a[i][c]; 
                }
        
        r ++;
    }
    
    for(int i = n - 1; i >= 0; i --)
        for(int j = i + 1; j < n; j ++)
            a[i][n] -= a[i][j] * a[j][n];
    
    if(r < n){
        for(int i = r; i < n; i ++){
            if(fabs(a[i][n]) > eps) return 0;;
        return 2;
        }    
    }
    
    return 1;
}
```



## 容斥原理

在[计数](https://baike.baidu.com/item/计数/9276342)时，必须注意没有重复，没有遗漏。为了使[重叠](https://baike.baidu.com/item/重叠/9009438)部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目[排斥](https://baike.baidu.com/item/排斥/10717656)出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。

选择的个体的个数是奇数就加，是偶数就减

## 博弈论

NIM游戏 
给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。

我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。
所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。
NIM博弈不存在平局，只有先手必胜和先手必败两种情况。

定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0

公平组合游戏ICG
若一个游戏满足：

由两名玩家交替行动；
在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；
不能行动的玩家判负；
则称该游戏为一个公平组合游戏。
NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。

有向图游戏
给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。
任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。

Mex运算
设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S

SG函数
在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：
SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})
特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。

有向图游戏的和
设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。
有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：
SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)

定理
有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。
有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。

# 五、动态规划

## 背包问题

- 01背包问题

```c++
 for(int i = 1; i <= n; i ++)
        for(int j = m; j >= v[i]; j --)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
```



- 完全背包问题

每件物品可以取无限个

```c++
for(int i = 1; i <= n ; i ++)
	for(int j = v[i]; j <= V; j ++)
    	f[j] = max(f[j], f[j - v[i]] + w[i])
```



- 多重背包

时间复杂度 ：$O( N * V * logs)$

空间要开$ N * log s$

每件物品有个数限制

二进制优化核心思想：把一定数量的物品打包成一件，转化成01背包问题

假设一件物品有$s$件， $1 + 2 + ... 2^k < s   1 + 2 + ... 2^k  + c = s   c < 2^{k + 1}$

$1 , 2 + ... 2^k$  , $c$可以组合出任意小于等于$s $的数，则就把有$n$件物品的多重背包问题转化为有$n*logs$的01背包问题 



```c++
//二进制优化
int n, V;//物品数量，背包最大容量
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> V;
    int cnt = 0;
    for(int i = 1; i <= n; i ++){
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while(k <= s){
            cnt ++;
            v[cnt] = k * a;
            w[cnt] = k * b;
            s -= k;
            k *= 2;
        }
        if(s > 0){
            cnt ++;
            v[cnt] = s * a;
            w[cnt] = s * b;
        }
    }
    n = cnt;
    for(int i = 1; i <= n; i ++)
        for(int j = V; j >= v[i]; j --)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
//单调队列优化
const int N = 40010;
int f[N], q[N];
int last_f[N];
int n, m;

int main()
{   
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for(int i = 1; i <= n; i ++){
        int v, w, s;
        cin >> v >> w >> s;

        memcpy(last_f, f, sizeof(f));
        for(int r = 0; r < v;  r ++){
            int hh = 0, tt = -1;
            for(int j = r; j <= m; j += v){
                if(hh <= tt && q[hh] < j - s * v) hh ++;
                while(hh <= tt && last_f[q[tt]] + (j - q[tt]) / v * w <= last_f[j]) tt --;
                q[++ tt] = j;
                f[j] = max(f[j], last_f[q[hh]] + (j - q[hh]) / v * w);
            }
        }
    }

    cout << f[m] << "\n";

    return 0;
}            
```

- 分组背包问题

​	物品分为几组, 每个组中只能选择一个物品

```c++
//枚举每组物品，
//更新每组，用的是前一组数据，因此容量从大到小枚举
 for(int i = 1; i <= n; i ++)
        for(int j = V; j >= 0; j --)
            for(int k = 0; k <= s[i]; k ++)
                if(v[i][k] <= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
```



- 背包问题求方案数

  - 求体积恰好装到一定容量的方案数，这种的一般都是价值等于体积，体积可以直接代表价值，因此可以确定状态从哪里转移过来。
        只需要把状态转移从求最大值换成求和即可。
  - 求最优方案的方案数，记录最大价值同时也要记录此时的方案数，因此要多开一个数组，方案数转移的时候要确定是从哪个状态转移过来的，
        把转移过来的方案数加上即可。
  
  ```c++
  /*
  有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
  
  第 i 件物品的体积是 vi，价值是 wi。
  
  求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
  
  输出 最优选法的方案数。注意答案可能很大，请输出答案模 10^9+7 的结果。
  */
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  
  using namespace std;
  const int N = 1010, mod = 1e9 + 7;
  int f[N];
  int g[N];
  int n, m;
   
  int main()
  {
      cin >> n >> m;
      g[0] = 1;
      for(int i = 1; i <= n; i ++){
          int v, w;
          scanf("%d%d", &v, &w);
          for(int j = m; j >= v; j --){
              int maxw = max(f[j], f[j - v] + w);
              int cnt = 0;
              if(f[j] == maxw) cnt = g[j];
              if(f[j - v] + w == maxw) cnt = (cnt + g[j - v]) % mod;
              g[j] = cnt % mod;
              f[j] = maxw;
          }
      }
      int maxn = 0;
      for(int i = 0; i <= m; i ++) maxn = max(maxn, f[i]);
      int cnt = 0;
      for(int i = 0; i <= m; i ++)
          if(f[i] == maxn) cnt = (cnt + g[i]) % mod;
          
      cout << cnt << "\n";
      
      return 0;
  }
  ```
  
  
  
- 背包问题求具体方案

  ```c++
  /*
  有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
  
  第 i 件物品的体积是 vi，价值是 wi。
  
  求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
  
  输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。
  */
  #include <bits/stdc++.h>
  
  using namespace std;
  
  const int N = 1010;
  int f[N][N];
  int v[N], w[N];
  int n, m;
  /*
  不能倒着从后往前推每个物品选不选
  */
  int main()
  {
      scanf("%d%d", &n, &m);
      for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i];
      for(int i = n; i; i --){
          for(int j = 0; j <= m; j ++){
              f[i][j] = f[i + 1][j];
              if(j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
          }
      }
      //f[1][m]是最大值
      int j = m;
      for(int i = 1; i <= n; i ++){
          if(j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i]){
              cout << i << ' ';
              j -= v[i];
          }
      }
  
      return 0;
  }
  ```

  

## 线性dp

- LIS

  ```c++
  const int N = 100010， -INF = 0x3f3f3f3f;
  int a[N];
  int q[N];
  int n;
  
  int main()
  {
      scanf("%d", &n);
      for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
      
      int cnt = 0;//表示当前已经找到了长度为cnt的上升子序列
      q[0] = -INF;
      for(int i = 1; i <= n; i ++){
          int l = 0, r = cnt;
          while(l < r){
              int mid = l + r + 1 >> 1;
              
              if(q[mid] < a[i]) l = mid;
              else r = mid - 1;
          }
          cnt = max(cnt, r + 1);
          q[r + 1] = a[i];
      }
      
      printf("%d", cnt);
      
      return 0;
  }
  ```




- LCS

  ```c++
  #include <bits/stdc++.h>
  
  using namespace std;
  
  const int N = 1010;
  string a, b;
  int dp[N][N];
  int n, m;
  
  int main()
  {
      cin >> n >> m;
      cin >> a >> b;
      a = " " + a, b = " " + b;
      
      for(int i = 1; i <= n; i ++)
          for(int j = 1; j <= m; j ++){
             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
             if(a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1;
          }
      
      printf("%d", dp[n][m]);
              
      return 0;
  }
  ```

  

- LCIS

  ```c++
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 3010;
  int a[N], b[N];
  int dp[N][N];
  int n;
  
  int main()
  {
      scanf("%d", &n);
      for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
      for(int i = 1; i <= n; i ++) scanf("%d", &b[i]);
      
      for(int i = 1; i <= n; i ++){
          int maxv = 1;
          for(int j = 1; j <= n; j ++){
              dp[i][j] = dp[i - 1][j];
              if(a[i] == b[j]) dp[i][j] = max(dp[i][j], maxv);
              if(b[j] < a[i]) maxv = max(maxv, dp[i - 1][j] + 1);
              /*
              {
                  dp[i][j] = max(dp[i][j], 1);
                  for(int k = 1; k < j; k ++)
                      if(b[k] < a[i])
                          dp[i][j] = max(dp[i][j], dp[i - 1][k] + 1);
              }
              */
          }
      }
      
      int res = 1;
      for(int i = 1; i <= n; i ++) res = max(res, dp[n][i]);
      
      printf("%d", res);
      
      return 0;
  }
  ```




## 区间dp

状态为一个区间的状态，通常枚举区间长度，再枚举区间起点

常用技巧：

- 破环成链

  

```c++
/*
AcWing 1068. 环形石子合并
将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。

规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。

请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：

选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。
选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。
*/
#include <bits/stdc++.h>

#define endl "\n"

using namespace std;

const int N = 410;
int s[N];
int a[N];
int f1[N][N], f2[N][N];
int n;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    for(int i = 1; i <= n; i ++){
        cin >> a[i];
        a[n + i] = a[i];
    }

    for(int i = 1; i <= n * 2; i ++) s[i] = a[i] + s[i - 1];

    memset(f1, 0x3f, sizeof(f1));
    for(int len = 1; len <= n * 2; len ++)
        for(int l = 1; l + len - 1 <= n * 2; l ++){
            int r = l + len - 1;
            if(len == 1) f1[l][r] = f2[l][r] = 0;
            else{
                for(int k = l; k < r; k ++)
                    f1[l][r] = min(f1[l][r], f1[l][k] + f1[k + 1][r] + s[r] - s[l - 1]);

                for(int k = l; k < r; k ++)
                    f2[l][r] = max(f2[l][r], f2[l][k] + f2[k + 1][r] + s[r] - s[l - 1]);
            }
        }

    int res = 1e9;
    for(int i = 1; i <= n; i ++)
        res = min(res, f1[i][i + n - 1]);
    cout << res << endl;

    res = 0;
    for(int i = 1; i <= n; i ++)
        res = max(res, f2[i][i + n - 1]);

    cout << res << endl;

    return 0;
}
```



## 树形dp

在树上面进行dp父节点表示的状态集合用子节点来更新，父节点可能有多个状态（与状态机模型结合），通常采用dfs实现

```c++
/*
AcWing 285. 没有上司的舞会
Ural 大学有 N 名职员，编号为 1∼N。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。
*/
#include <bits/stdc++.h>

using namespace std;
using PII = pair<int, int>;
const int N = 6007;
vector<int> to[N];
int f[N][2];
int a[N], father[N];
int n;

void dp(int u)
{   
    f[u][1] = a[u];
    for(auto ver : to[u]){
        dp(ver);
        f[u][1] = max(f[u][1], f[ver][0] + a[u]);
        f[u][0] = max({f[u][0], f[ver][0], f[ver][1]});
    }
}

void sovle()
{   
    cin >> n;
    for(int i = 1; i <= n; i ++)
        cin >> a[i];
    
    for(int i = 1; i < n; i ++){
        int u, v;
        cin >> u >> v;
        father[u] = v; 
        to[v].push_back(u);
    }

    int root = 1;
    while(father[root]) root ++;

    dp(root);
    cout << max(f[root][1], f[root][0]) << "\n";
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setiosflags(ios::fixed) << setprecision(12);

    int T = 1;
    //cin >> T;
    while(T --) sovle();

    return 0;
}

```



- 换根法

  - 一般每个点作为根答案不同

  - 通常两次扫描，父节点利用子节点更新信息，子节点利用父节点更新信息

    

```c++
/*
AcWing 287. 积蓄程度
有一个树形的水系，由 N−1 条河道和 N 个交叉点组成。

我们可以把交叉点看作树中的节点，编号为 1∼N，河道则看作树中的无向边。

每条河道都有一个容量，连接 x 与 y 的河道的容量记为 c(x,y)。

河道中单位时间流过的水量不能超过河道的容量。

有一个节点是整个水系的发源地，可以源源不断地流出水，我们称之为源点。

除了源点之外，树中所有度数为 1 的节点都是入海口，可以吸收无限多的水，我们称之为汇点。

也就是说，水系中的水从源点出发，沿着每条河道，最终流向各个汇点。

在整个水系稳定时，每条河道中的水都以单位时间固定的水量流向固定的方向。

除源点和汇点之外，其余各点不贮存水，也就是流入该点的河道水量之和等于从该点流出的河道水量之和。

整个水系的流量就定义为源点单位时间发出的水量。

在流量不超过河道容量的前提下，求哪个点作为源点时，整个水系的流量最大，输出这个最大值。
*/
#include <bits/stdc++.h>

using namespace std;
using LL = long long;
const int N = 200010, M = N << 1, INF = 0x3f3f3f3f;
int h[N], e[M], w[M], ne[M], idx;
int up[N], down[N], deg[N];
int n;

void add(int u, int v, int c)
{
    e[idx] = v, w[idx] = c, ne[idx] = h[u], h[u] = idx ++;
}

void dfs1(int u, int fa)
{   
    for(int i = h[u]; ~i; i = ne[i]){
        int ver = e[i];
        if(ver == fa) continue;
        dfs1(ver, u);
        if(deg[ver] == 1) down[u] += w[i];
        else down[u] += min(down[ver], w[i]);
    }
}

void dfs2(int u, int fa)
{
    for(int i = h[u]; ~i; i = ne[i]){
        int ver = e[i];
        if(ver == fa) continue;
        if(deg[u] == 1) up[ver] = w[i];
        else up[ver] = min(w[i], down[u] - min(down[ver], w[i]) + up[u]);
        dfs2(ver, u);
    }
}

void sovle()
{   
    cin >> n;
    memset(h, -1, 4 * (n + 1));
    memset(down, 0, 4 * (n + 1));
    memset(up, 0, 4 * (n + 1));
    memset(deg, 0, 4 * (n + 1));
    idx = 0;
    for(int i = 1; i < n; i ++){
        int u, v, t;
        cin >> u >> v >> t;
        add(u, v, t);
        add(v, u, t);
        deg[u] ++, deg[v] ++;
    }

    dfs1(1, -1);
    dfs2(1, -1);
    int res = 0;
    for(int i = 1; i <= n; i ++){
        res = max(res, down[i] + up[i]);
    }

    cout << res << "\n";
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setiosflags(ios::fixed) << setprecision(12);
    int T = 1;
    cin >> T;
    while(T --){
        sovle();
    }

    return 0;
}
```



## 环形后效性处理

所有的状态依赖关系构成环，需要进行特殊处理：

- 分类讨论

  可以假定某一环节的具体状态是什么，从而在这一状态下进行dp, 要把这一环节的所有状态都假定一遍

  ```c++
  /*
  AcWing 288. 休息时间
  在某个星球上，一天由 N 个小时构成，我们称 0 点到 1 点为第 1 个小时、1 点到 2 点为第 2 个小时，以此类推。
  
  在第 i 个小时睡觉能够恢复 Ui 点体力。
  
  在这个星球上住着一头牛，它每天要休息 B 个小时。
  
  它休息的这 B 个小时不一定连续，可以分成若干段，但是在每段的第一个小时，它需要从清醒逐渐入睡，不能恢复体力，从下一个小时开始才能睡着。
  
  为了身体健康，这头牛希望遵循生物钟，每天采用相同的睡觉计划。
  
  另外，因为时间是连续的，即每一天的第 N 个小时和下一天的第 1 个小时是相连的（N 点等于 0 点），这头牛只需要在每 N 个小时内休息够 B 个小时就可以了。
  
  请你帮忙给这头牛安排一个睡觉计划，使它每天恢复的体力最多。
  */
  #include <bits/stdc++.h>
  
  using namespace std;
  using LL = long long;
  int mod = 998'244'353;
  const int N = 4000, INF = 0x3f3f3f3f;
  int f[2][N][2];
  int a[N];
  int n, m;
  
  void sovle()
  { 
      cin >> n >> m;
      for(int i = 1; i <= n; i ++)
          cin >> a[i];
  
      int res = 0;
      //第n小时在睡觉
      memset(f, -0x3f, sizeof(f));
      f[1][0][0] = 0, f[1][1][1] = a[1];
      for(int i = 2; i <= n; i ++)
          for(int j = 0; j <= m; j ++){
              f[i & 1][j][0] = max(f[i - 1 & 1][j][0], f[i - 1 & 1][j][1]);
              if(j) f[i & 1][j][1] = max(f[i - 1 & 1][j - 1][0], f[i - 1 & 1][j - 1][1] + a[i]);
          }
      res = f[n & 1][m][1];
  
      //第n小时不在睡觉
      memset(f, -0x3f, sizeof(f));
      f[1][0][0] = 0, f[1][1][1] = 0;
      for(int i = 2; i <= n; i ++)
          for(int j = 0; j <= m; j ++){
              f[i & 1][j][0] = max(f[i - 1 & 1][j][0], f[i - 1 & 1][j][1]);
              if(j) f[i & 1][j][1] = max(f[i - 1 & 1][j - 1][0], f[i - 1 & 1][j - 1][1] + a[i]);
          }
      res = max(res, f[n & 1][m][0]);
  
      cout << res << "\n";
  }
  
  signed main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cout << setiosflags(ios::fixed) << setprecision(12);
      int T = 1;
      //cin >> T;
      while(T --){
          sovle();
      }
  
      return 0;
  }
  ```

- 破环成链

  ```c++
  /*
  AcWing 289. 环路运输
  在一条环形公路旁均匀地分布着 N 座仓库，编号为 1∼N，编号为 i 的仓库与编号为 j 的仓库之间的距离定义为 dist(i,j)=min(|i−j|,N−|i−j|)，也就是逆时针或顺时针从 i 到 j 中较近的一种。
  
  每座仓库都存有货物，其中编号为 i 的仓库库存量为 Ai。
  
  在 i 和 j 两座仓库之间运送货物需要的代价为 Ai+Aj+dist(i,j)。
  
  求在哪两座仓库之间运送货物需要的代价最大
  */
  #include <bits/stdc++.h>
  
  using namespace std;
  using LL = long long;
  int mod = 998'244'353;
  const int N = 2000007, INF = 0x3f3f3f3f;
  int a[N], q[N];
  int n;
  
  void sovle()
  { 
      cin >> n;
      for(int i = 1; i <= n; i ++){
          cin >> a[i];
          a[i + n] = a[i];
      }
  
      int res = 0;
      int hh = 0, tt = -1;
      int k = n / 2;
  
      for(int i = 1; i <= n * 2; i ++){
          while(hh <= tt && q[tt] - q[hh] + 1 > k) hh ++;
          if(hh <= tt) res = max(res, i - q[hh] + a[i] + a[q[hh]]);
          while(hh <= tt && -i + a[i] >= -q[tt] + a[q[tt]]) tt --;
          q[++ tt] = i;
      }
  
      cout << res << "\n";
  }
  
  signed main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cout << setiosflags(ios::fixed) << setprecision(12);
      int T = 1;
      //cin >> T;
      while(T --){
          sovle();
      }
  
      return 0;
  }
  ```

  

- 高斯消元处理环形后效性

  ```c++
  /*
  给定一张 N×M 的棋盘，有一个机器人处于 (x,y) 位置。
  
  这个机器人可以进行很多轮行动，每次等概率地随机选择停在原地、向左移动一格、向右移动一格或向下移动一格。
  
  当然机器人不能移出棋盘。
  
  求机器人从起点走到最后一行的任意一个位置上，所需行动次数的数学期望值。
  n <= 1000
  */
  #include <bits/stdc++.h>
  
  using namespace std;
  using LL = long long;
  int mod = 998'244'353;
  const int N = 1007, INF = 0x3f3f3f3f;
  double f[N][N];
  double a[N][N];
  int n, m, x, y;
  
  void gauss()
  {
      for(int i = 1; i <= m; i ++){
          double t = a[i + 1][i] / a[i][i];
          a[i + 1][i] = 0;
          a[i + 1][i + 1] -= a[i][i + 1] * t;
          a[i + 1][m + 1] -= a[i][m + 1] * t;
      }
  
      for(int i = m; i >= 1; i --){
          a[i - 1][m + 1] -= a[i - 1][i] / a[i][i] * a[i][m + 1];
          a[i - 1][i] = 0;
      }
  
      for(int i = 1; i <= m; i ++){
          a[i][m + 1] /= a[i][i];
      }
  }
  
  void sovle()
  { 
      cin >> n >> m >> x >> y;
      if(m == 1) cout << 2.0 * (n - x) << "\n";
      else{
          for(int i = n - 1; i >= x; i --){
              a[1][1] = 2.0 / 3, a[1][2] = -1.0 / 3;
              a[m][m - 1] = -1.0 / 3, a[m][m] = 2.0 / 3;
              a[1][m + 1] = f[i + 1][1] / 3 + 1;
              a[m][m + 1] = f[i + 1][m] / 3 + 1;
              for(int j = 2; j < m; j ++){
                  a[j][j - 1] = -1.0 / 4, a[j][j] = 3.0 / 4, a[j][j + 1] = -1.0 / 4;
                  a[j][m + 1] = f[i + 1][j] / 4 + 1;
              }
  
              gauss();
  
              for(int j = 1; j <= m; j ++)
                  f[i][j] = a[j][m + 1];
  
          }
  
          cout << f[x][y] << "\n";
      }
  }
  
  signed main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cout << setiosflags(ios::fixed) << setprecision(4);
      int T = 1;
      //cin >> T;
      while(T --){
          sovle();
      }
  
      return 0;
  }
  ```




## 状态压缩dp

思想是用一个数，这个数的每个位置表示所有物品或者行列的状态

- 棋盘式

  一般是用一个数表示一行或者一列的状态

  ```c++
  /*
  求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案
  1≤N,M≤11
  */
  #include <bits/stdc++.h>
  
  using namespace std;
  using LL = long long;
  int mod = 998'244'353;
  const int N = 12, M = 1 << 11, INF = 0x3f3f3f3f;
  LL f[N][M];
  bool st[M];
  vector<int> from[M];
  int n, m;
  
  void sovle()
  { 
      for(int i = 0; i < 1 << n; i ++){
          bool ok = true;
          int cnt = 0;
          for(int j = 0; j < n; j ++)
              if(i >> j & 1){
                  if(cnt & 1){
                      ok = false;
                      break;
                  }
                  cnt = 0;
              }else cnt ++;
          if(cnt & 1) ok = false;
          st[i] = ok;
      }
  
      for(int i = 0; i < 1 << n; i ++){
          from[i].clear();
          for(int k = 0; k < 1 << n; k ++){
              if((i & k) == 0 && st[i | k]){
                  from[i].push_back(k);
              }
          }
      }
  
      memset(f, 0, sizeof(f));
      f[0][0] = 1;
      for(int i = 1; i <= m; i ++){
          for(int j = 0; j < 1 << n; j ++){
              for(auto k : from[j]){
                  f[i][j] += f[i - 1][k];
              }
          }
      }
  
      cout << f[m][0] << "\n";
  }
  
  signed main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cout << setiosflags(ios::fixed) << setprecision(4);
      int T = 1;
      //cin >> T;
      while(cin >> n >> m, n || m){
          sovle();
      }
  
      return 0;
  }
  ```

  

- 集合式

  用一个数表示每个”点“的状态

  ```c++
  /*
  给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1 的最短 Hamilton 路径。
  
  Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。
  */
  #include <bits/stdc++.h>
  
  using namespace std;
  using LL = long long;
  int mod = 998'244'353;
  const int N = 21, M = 1 << 20, INF = 0x3f3f3f3f;
  int d[N][N];
  int f[M][N];
  int n;
  
  void sovle()
  {   
      cin >> n;
      for(int i = 0; i < n; i ++)
          for(int j = 0; j < n; j ++)
              cin >> d[i][j];
  
      memset(f, 0x3f, sizeof(f));
      f[1][0] = 0;
      for(int i = 0; i < 1 << n; i ++)
          for(int j = 0; j < n; j ++){
              if(i >> j & 1){
                  for(int k = 0; k < n; k ++){
                      if(i >> k & 1){
                          f[i][j] = min(f[i][j], f[i - (1 << j)][k] + d[k][j]);
                      }
                  }
              }
          }
  
      cout << f[(1 << n) - 1][n - 1];
  }
  
  signed main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cout << setiosflags(ios::fixed) << setprecision(4);
      int T = 1;
      //cin >> T;
      while(T --){
          sovle();
      }
  
      return 0;
  }
  ```

  

## 数位dp

题目一般是给定一个区间求区间内满足某种性质的数的个数或其他东西

- 递推
  - .采用前缀和的思想，把要求的区间转化成两个区间的差
  - 从高位到低位，采用一颗树的形式思考，左子树是这一位选择$0 \ldots a[i] - 1$的方案，右子树是这一位选择$a[i]$的方案 左子树所有的方案数通常可以通过预处理得到，预处理的过程大多数为dp，右子树一直能走到最后一位才能得到一种合法方案
  -  这种分类的思想是基于：最终的方案每一位都要填一个数，从高位到地位考虑，分成两个子树（这样考虑的好处是，简便的使得考虑的方案都是小于区间			上界的），这一位填的所有合法数的所有方案等价于所有合法的方案）。

- 记忆化搜索

​		$f[i] [j]$记忆化的内容是从高到低位当前枚举到第$i$位，前面的状态为j(不包括第$i$位，j通常根据题目来定) 且不贴合上界(也就是这一位

​		没有上界限制，只有题目限制)的方案数，递归辅助信息通常有是否有限制，是否有前导零等

​        这样表示状态的原因是，这一位没有贴合上界的方案比贴合上界的多，且前面状态用到不贴合上界的方案也多，把这一状态记忆化就能大大优化时间。

```c++
/*
科协里最近很流行数字游戏。

某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。

现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。
*/
#include <bits/stdc++.h>

using namespace std;
using LL = long long;
constexpr int mod = 998'244'353;
constexpr int N = 40, INF = 0x3f3f3f3f;
int f[N][10];
vector<int> nums;
int l, r;

int dp(int u, int pre, int lim)
{
    if(u == -1) return 1;
    
    if(!lim && ~f[u][pre]) return f[u][pre];

    int mx = lim ? nums[u] : 9;
    int res = 0;
    for(int i = 0; i <= mx; i ++){
        if(i < pre) continue;
        res += dp(u - 1, i, lim && i == mx);
    }

    return lim ? res : f[u][pre] = res;
}

int calc(int x)
{
    memset(f, -1, sizeof(f));
    nums.clear();
    while(x) nums.push_back(x % 10), x /= 10;

    return dp(nums.size() - 1, 0, 1);
}

void sovle()
{   
    cout << calc(r) - calc(l - 1) << "\n";
}
 
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setiosflags(ios::fixed) << setprecision(4);
    int T = 1;
    //cin >> T;
    while(cin >> l >> r){
        sovle();
    }

    return 0;
}
```



- 适当增加维护信息使得能够复用状态

  ```c++
  /*
  给出两个数a,ba,b，求出[a,b][a,b]中各位数字之和能整除原数的数的个数。
  */
  #include <bits/stdc++.h>
  
  using namespace std;
  using LL = long long;
  constexpr int mod = 998'244'353;
  constexpr int N = 20, INF = 0x3f3f3f3f;
  LL f[N][N * 10][N * 10];
  vector<int> nums;
  LL l, r;
  LL n;
  
  LL dp(int u, int sum, int s, int lim)
  {
      if(u == -1){
          if(sum == 0) return 0;
          if(s == 0 && sum == n) return 1;
          return 0;
      }
      
      if(!lim && ~f[u][sum][s]) return f[u][sum][s];
  
      int mx = lim ? nums[u] : 9;
      LL res = 0;
      for(int i = 0; i <= mx; i ++){
          res += dp(u - 1, sum + i, (10ll * s + i) % n,lim && i == mx);
      }
  
      return lim ? res : f[u][sum][s] = res;
  }
  
  LL calc(LL x)
  {
      nums.clear();
      while(x) nums.push_back(x % 10), x /= 10;
  
      LL res = 0;
      for(n = 1; n <= 9 * nums.size(); n ++){
          memset(f, -1, sizeof(f));
          res += dp(nums.size() - 1, 0, 0, 1);
      }
      return res;
  }
  
  void sovle()
  {   
      cin >> l >> r;
      cout << calc(r) - calc(l - 1) << "\n";
  }
   
  signed main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cout << setiosflags(ios::fixed) << setprecision(4);
      int T = 1;
      //cin >> T;
      while(T --){
          sovle();
      }
  
      return 0;
  }
  ```






## 计数类dp

- 计数类dp通常与组合数有关

```c++
/* AcWing 306.杰拉尔德和巨型象棋
给定一个 H×W 的棋盘，棋盘上只有 N 个格子是黑色的，其他格子都是白色的。

在棋盘左上角有一个卒，每一步可以向右或向下移动一格，并且不能移动到黑色格子中。

求这个卒从左上角移动到右下角，一共有多少种路线。
*/
#include <bits/stdc++.h>

using namespace std;
using LL = long long;
constexpr int mod = 1000'000'007;
constexpr int N = 100007, INF = 0x3f3f3f3f;
LL fact[N], infact[N];
LL f[2007];

int qmi(int a, int k, int p)
{
    int res = 1;
    while(k){
        if(k & 1) res = (LL)res * a % p;
        k >>= 1;
        a = (LL)a * a % p;
    }
    return res;
}

void init()
{
    fact[0] = infact[0] = 1;
    for(int i = 1; i < N; i ++){
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; 
    }
}

LL C(int a, int b)
{
    return (LL)fact[a] * infact[b] % mod * infact[a - b] % mod;
}

void sovle()
{   
    init();
    int n, m, k;
    cin >> n >> m >> k;
    vector<pair<int, int>> a;
    for(int i = 1; i <= k; i ++){
        int x, y;
        cin >> x >> y;
        a.push_back({x, y});
    }
    a.push_back({n, m});

    sort(a.begin(), a.end());

    for(int i = 0; i < a.size(); i ++){
        auto [xi, yi] = a[i];
        f[i] = C(xi - 1 + yi - 1, xi - 1);
        for(int j = 0; j < i; j ++){
            auto [xj, yj] = a[j];
            if(xj <= xi && yj <= yi){
                LL t = f[j] * C(xi - xj + yi - yj, xi - xj) % mod;
                f[i] = (f[i] - t + mod) % mod;
            }
        }
    }

    cout << f[a.size() - 1] << "\n";
}
 
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setiosflags(ios::fixed) << setprecision(4);
    int T = 1;
    //cin >> T;
    while(T --){
        sovle();
    }

    return 0;
}
```



- 状态机模型

一个状态可能受到其他状态的影响，有可能几个状态组合才能完成一次完整操作，因此可以把每个状态分离开来，每个点都有多种状态，就每个点的多种状态求解

- 单调队列优化dp

  状态转移需要是一段连续数的最大值或最小值，用单调队列来优化

- 斜率优化dp

  通常状态转移都是需要前面一堆状态的值来转移，(目的要找斜率第一条大于当前斜率的点)

  优化的方式就是把前面需要的每个状态看成一个点，当前状态就是一条斜率固定的直线

  这样可以分成两种1.每个状态的直线斜率依次递增，每次加进来的点横坐标递增，这样只需对头队尾分别维护即可， 对头就是最值

  ​							  2.每个状态的直线斜率不定，每次加进来的点横坐标递增，每次队尾依然可以维护，但对头不行，最值需要二分来找。









# 六、其他知识点

- 排序不等式

  ```c++
  对于非严格递增序列a1 ~ an, b1 ~ bn,
  ai * bi相加的最大值是a1 * b1 + ... + an * bn
      		最小值是a1 * bn + ... + an * b1
  理解 同序相乘一定大于逆序相乘，最大就都是同序， 最小就都是逆序
  ```

- $O(1)$计算一个点到若干点的最大曼哈顿距离

  ```c++
  /*
  Codeforces Round #798 (Div. 2) 1689_D
  */
  
  #include <bits/stdc++.h>
  
  using namespace std;
  using LL = long long;
  using PII = pair<int, int>;
  using PLL = pair<LL , LL>;
  
  const int N = 1010, M = N << 1;
  const int mod = 998244353;
  const int INF = 0x3f3f3f3f;
  char g[N][N];
  int n, m;
  
  void solve()
  {  
      cin >> n >> m;
      int mx[4] = {0};
      memset(mx, -0x3f, sizeof(mx));
      for(int i = 1; i <= n; i ++)
          for(int j = 1; j <= m; j ++){
              cin >> g[i][j];
  
              if(g[i][j] == 'B'){
                  mx[0] = max(mx[0], i + j);
                  mx[1] = max(mx[1], -i - j);
                  mx[2] = max(mx[2], - i + j);
                  mx[3] = max(mx[3], i - j);
              }
          }
      
      int x = 0, y = 0, ans = INF;
      for(int i = 1; i <= n; i ++)
          for(int j = 1; j <= m; j ++){
              int t = max({
                  mx[0] - i - j,//所有在我右下角距离我最远的
                  mx[1] + i + j ,//所有在我左上角距离我最远的
                  mx[2] + i - j,//所有在我右上角距离我最远的
                  mx[3] + j - i,//所有在我左下角距离我最远的
              });
  
              if(t < ans){
                  x = i, y = j;
                  ans = t;
              }
          }
  
      cout << x << ' ' << y << "\n";
  }
  
  signed main()
  {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
     
      int T = 1;
      cin >> T;
      while(T --) solve();
  
      return 0;
  }
  ```

  

- 快速枚举集合的非全子集

  ```c++
  //i为二进制数表示元素存在与否，j就为i的所有非全子集
      for(int i = 1; i < 1 << n; i ++){
          for(int j = (i - 1) & i; j; j = (j - 1) & i){
  
          }
      }
  
  ```

  
